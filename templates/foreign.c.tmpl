// Code generated by github.com/cshum/vipsgen. DO NOT EDIT.

#include "foreign.h"

// JPEG buffer save wrapper
{{if .HasJpegSaver}}
int jpegsave_buffer_wrapper(VipsImage *in, VipsBlob **out, int quality, int strip,
                         int optimize_coding, int interlace, int subsample_mode,
                         int trellis_quant, int overshoot_deringing,
                         int optimize_scans, int quant_table) {
    return vips_jpegsave_buffer(in, out,
                              "Q", quality,
                              "strip", strip,
                              "optimize_coding", optimize_coding,
                              "interlace", interlace,
                              "subsample_mode", subsample_mode,
                              "trellis_quant", trellis_quant,
                              "overshoot_deringing", overshoot_deringing,
                              "optimize_scans", optimize_scans,
                              "quant_table", quant_table,
                              NULL);
}
{{end}}

// PNG buffer save wrapper
{{if .HasPngSaver}}
int pngsave_buffer_wrapper(VipsImage *in, VipsBlob **out, int compression, int strip,
                        int interlace, int filter, int palette, int quality,
                        double dither, int bitdepth) {
    return vips_pngsave_buffer(in, out,
                             "compression", compression,
                             "strip", strip,
                             "interlace", interlace,
                             "filter", filter,
                             "palette", palette,
                             "Q", quality,
                             "dither", dither,
                             "bitdepth", bitdepth,
                             NULL);
}
{{end}}

// WEBP buffer save wrapper
{{if .HasWebpSaver}}
int webpsave_buffer_wrapper(VipsImage *in, VipsBlob **out, int quality, int strip,
                         int lossless, int near_lossless, int reduction_effort) {
    return vips_webpsave_buffer(in, out,
                              "Q", quality,
                              "strip", strip,
                              "lossless", lossless,
                              "near_lossless", near_lossless,
                              "reduction_effort", reduction_effort,
                              NULL);
}

int webpsave_buffer_profile_wrapper(VipsImage *in, VipsBlob **out, int quality, int strip,
                                 int lossless, int near_lossless, int reduction_effort,
                                 const char* profile) {
    return vips_webpsave_buffer(in, out,
                              "Q", quality,
                              "strip", strip,
                              "lossless", lossless,
                              "near_lossless", near_lossless,
                              "reduction_effort", reduction_effort,
                              "profile", profile,
                              NULL);
}
{{end}}

// HEIF buffer save wrapper
{{if .HasHeifSaver}}
int heifsave_buffer_wrapper(VipsImage *in, VipsBlob **out, int quality, int lossless) {
    return vips_heifsave_buffer(in, out,
                              "Q", quality,
                              "lossless", lossless,
                              NULL);
}
{{end}}

// TIFF buffer save wrapper
{{if .HasTiffSaver}}
int tiffsave_buffer_wrapper(VipsImage *in, VipsBlob **out, int quality, int strip,
                         int compression, int predictor, int pyramid, int tile,
                         int tile_width, int tile_height, double xres, double yres) {
    return vips_tiffsave_buffer(in, out,
                              "Q", quality,
                              "strip", strip,
                              "compression", compression,
                              "predictor", predictor,
                              "pyramid", pyramid,
                              "tile", tile,
                              "tile_width", tile_width,
                              "tile_height", tile_height,
                              "xres", xres,
                              "yres", yres,
                              NULL);
}
{{end}}

// GIF buffer save wrapper (CGIF)
{{if .HasCgifSaver}}
int gifsave_buffer_wrapper(VipsImage *in, VipsBlob **out, double dither, int effort, int bitdepth) {
    return vips_gifsave_buffer(in, out,
                             "dither", dither,
                             "effort", effort,
                             "bitdepth", bitdepth,
                             NULL);
}
{{end}}

// GIF buffer save wrapper through Magick (legacy)
{{if .HasLegacyGifSaver}}
int magicksave_buffer_wrapper(VipsImage *in, VipsBlob **out, const char* format, int quality) {
    return vips_magicksave_buffer(in, out,
                                "format", format,
                                "quality", quality,
                                NULL);
}
{{end}}

// AVIF buffer save wrapper through HEIF
{{if .HasAvifSaver}}
int avifsave_buffer_wrapper(VipsImage *in, VipsBlob **out, int quality, int lossless,
                         int speed, int strip) {
    return vips_heifsave_buffer(in, out,
                              "compression", VIPS_FOREIGN_HEIF_COMPRESSION_AV1,
                              "Q", quality,
                              "lossless", lossless,
                              "effort", 9 - speed,
                              "strip", strip,
                              NULL);
}
{{end}}

// JP2K buffer save wrapper
{{if .HasJp2kSaver}}
int jp2ksave_buffer_wrapper(VipsImage *in, VipsBlob **out, int quality, int lossless,
                         int tile_width, int tile_height, int subsample_mode) {
    return vips_jp2ksave_buffer(in, out,
                              "Q", quality,
                              "lossless", lossless,
                              "tile_width", tile_width,
                              "tile_height", tile_height,
                              "subsample_mode", subsample_mode,
                              NULL);
}
{{end}}

// Helper function to extract bytes from a VipsBlob and handle all the cleanup
// Uses the vips error system for more detailed error reporting
unsigned char* blob_to_bytes(VipsBlob *blob, size_t *len) {
    if (blob == NULL) {
        vips_error("blob_to_bytes", "NULL blob pointer");
        *len = 0;
        return NULL;
    }

    VipsArea *area = VIPS_AREA(blob);
    if (area == NULL) {
        vips_error("blob_to_bytes", "NULL area pointer");
        *len = 0;
        return NULL;
    }

    if (area->data == NULL || area->length == 0) {
        vips_area_unref(area);
        vips_error("blob_to_bytes", "Empty blob data");
        *len = 0;
        return NULL;
    }

    // Set the length
    *len = area->length;

    // Mark that Go will handle the memory (prevent libvips from freeing it)
    area->free_fn = NULL;

    // Get a pointer to the data
    unsigned char *data = area->data;

    // Unref the area (its data won't be freed since we set free_fn to NULL)
    vips_area_unref(area);

    return data;
}
