// Code generated by github.com/cshum/vipsgen. DO NOT EDIT.

package vips

// #include "vips.h"
import "C"
import (
	"fmt"
	"sync"
	"unsafe"
)

// Image contains a libvips image and manages its lifecycle.
type Image struct {
	image  *C.VipsImage
	format ImageType
	lock   sync.Mutex
}

// setImage resets the image for this image and frees the previous one
func (r *Image) setImage(image *C.VipsImage) {
	r.lock.Lock()
	defer r.lock.Unlock()

	if r.image == image {
		return
	}

	if r.image != nil {
		clearImage(r.image)
	}

	r.image = image
}

// Format returns the initial format of the vips image when loaded.
func (r *Image) Format() ImageType {
	return r.format
}

// Width returns the width of this image.
func (r *Image) Width() int {
	return int(r.image.Xsize)
}

// Height returns the height of this image.
func (r *Image) Height() int {
	return int(r.image.Ysize)
}

// Bands returns the number of bands for this image.
func (r *Image) Bands() int {
	return int(r.image.Bands)
}

// Close closes the image and frees the memory
func (r *Image) Close() {
	r.lock.Lock()
	if r.image != nil {
		clearImage(r.image)
		r.image = nil
	}
	r.lock.Unlock()
}

// clearImage frees the VipsImage
func clearImage(img *C.VipsImage) {
	C.g_object_unref(C.gpointer(img))
}

func handleImageError(out *C.VipsImage) error {
	if out != nil {
		clearImage(out)
	}
	return handleVipsError()
}

func handleVipsError() error {
	s := C.GoString(C.vips_error_buffer())
	C.vips_error_clear()

	return fmt.Errorf("%v", s)
}

func freeCString(s *C.char) {
	C.free(unsafe.Pointer(s))
}

func gFreePointer(ref unsafe.Pointer) {
	C.g_free(C.gpointer(ref))
}

func boolToInt(b bool) int {
	if b {
		return 1
	}
	return 0
}

func boolToStr(v bool) string {
	if v {
		return "TRUE"
	}
	return "FALSE"
}

func toGboolean(b bool) C.gboolean {
	if b {
		return C.gboolean(1)
	}
	return C.gboolean(0)
}

func fromGboolean(b C.gboolean) bool {
	return b != 0
}

var cStringsCache sync.Map

func cachedCString(str string) *C.char {
	if cstr, ok := cStringsCache.Load(str); ok {
		return cstr.(*C.char)
	}
	cstr := C.CString(str)
	cStringsCache.Store(str, cstr)
	return cstr
}

