// Code generated by github.com/cshum/vipsgen. DO NOT EDIT.

package vips

// #include "foreign.h"
import "C"
import (
	"fmt"
	"strings"
	"unsafe"
)

// ImageSaverSupport indicates which image savers are supported in this libvips build
var ImageSaverSupport = map[ImageType]bool{
	{{range .SupportedSavers}}{{.EnumName}}: true,
	{{end}}
}

{{if .HasJpegSaver}}
// JpegExportParams are options when exporting a JPEG to file or buffer
type JpegExportParams struct {
	StripMetadata      bool
	Quality            int
	Interlace          bool
	OptimizeCoding     bool
	SubsampleMode      Subsample
	TrellisQuant       bool
	OvershootDeringing bool
	OptimizeScans      bool
	QuantTable         int
}

// NewJpegExportParams creates default values for an export of a JPEG image.
// By default, vips creates interlaced JPEGs with a quality of 80/100.
func NewJpegExportParams() *JpegExportParams {
	return &JpegExportParams{
		Quality:   80,
		Interlace: true,
	}
}

// ExportJpeg exports the image as JPEG to a buffer.
func (r *Image) ExportJpeg(params *JpegExportParams) ([]byte, error) {
    if params == nil {
        params = NewJpegExportParams()
    }

    var buf unsafe.Pointer
    var length C.size_t

    err := C.jpegsave_buffer_wrapper(
        r.image, &buf, &length,
        C.int(params.Quality),
        C.int(boolToInt(params.StripMetadata)),
        C.int(boolToInt(params.OptimizeCoding)),
        C.int(boolToInt(params.Interlace)),
        C.int(params.SubsampleMode),
        C.int(boolToInt(params.TrellisQuant)),
        C.int(boolToInt(params.OvershootDeringing)),
        C.int(boolToInt(params.OptimizeScans)),
        C.int(params.QuantTable),
    )

    if err != 0 {
        return nil, handleVipsError()
    }

    return bufferToBytes(buf, length), nil
}
{{end}}

{{if .HasPngSaver}}
// PngExportParams are options when exporting a PNG to file or buffer
type PngExportParams struct {
	StripMetadata bool
	Compression   int
	Interlace     bool
	Quality       int
	Palette       bool
	Dither        float64
	Bitdepth      int
	// TODO fix this
	//Filter        PngFilter
}

// NewPngExportParams creates default values for an export of a PNG image.
// By default, vips creates non-interlaced PNGs with a compression of 6/10.
func NewPngExportParams() *PngExportParams {
	return &PngExportParams{
		Compression: 6,
		Interlace:   false,
		Palette:     false,
		// TODO fix this
		//Filter:      PngFilterNone,
	}
}

// ExportPng exports the image as PNG to a buffer.
func (r *Image) ExportPng(params *PngExportParams) ([]byte, error) {
	if params == nil {
		params = NewPngExportParams()
	}

    var buf unsafe.Pointer
    var length C.size_t

	// Call pngsave_buffer_wrapper
	err := C.pngsave_buffer_wrapper(
        r.image, &buf, &length,
		C.int(params.Compression),
		C.int(boolToInt(params.StripMetadata)),
		C.int(boolToInt(params.Interlace)),
		// TODO fix this
		// C.int(params.Filter),
		C.int(boolToInt(params.Palette)),
		C.int(params.Quality),
		C.double(params.Dither),
		C.int(params.Bitdepth),
	)

	if err != 0 {
		return nil, handleVipsError()
	}

    return bufferToBytes(buf, length), nil
}
{{end}}

{{if .HasWebpSaver}}
// WebpExportParams are options when exporting a WEBP to file or buffer
type WebpExportParams struct {
	StripMetadata   bool
	Quality         int
	Lossless        bool
	NearLossless    bool
	ReductionEffort int
	IccProfile      string
}

// NewWebpExportParams creates default values for an export of a WEBP image.
// By default, vips creates lossy images with a quality of 75/100.
func NewWebpExportParams() *WebpExportParams {
	return &WebpExportParams{
		Quality:         75,
		Lossless:        false,
		NearLossless:    false,
		ReductionEffort: 4,
	}
}

// ExportWebp exports the image as WEBP to a buffer.
func (r *Image) ExportWebp(params *WebpExportParams) ([]byte, error) {
	if params == nil {
		params = NewWebpExportParams()
	}

    var err C.int
    var buf unsafe.Pointer
    var length C.size_t

	// Call webp save wrapper with or without profile
	if params.IccProfile != "" {
		cProfile := C.CString(params.IccProfile)
		defer C.free(unsafe.Pointer(cProfile))

		err = C.webpsave_buffer_profile_wrapper(
            r.image, &buf, &length,
			C.int(params.Quality),
			C.int(boolToInt(params.StripMetadata)),
			C.int(boolToInt(params.Lossless)),
			C.int(boolToInt(params.NearLossless)),
			C.int(params.ReductionEffort),
			cProfile,
		)
	} else {
		err = C.webpsave_buffer_wrapper(
            r.image, &buf, &length,
			C.int(params.Quality),
			C.int(boolToInt(params.StripMetadata)),
			C.int(boolToInt(params.Lossless)),
			C.int(boolToInt(params.NearLossless)),
			C.int(params.ReductionEffort),
		)
	}

	if err != 0 {
		return nil, handleVipsError()
	}

    return bufferToBytes(buf, length), nil
}
{{end}}

{{if .HasHeifSaver}}
// HeifExportParams are options when exporting a HEIF to file or buffer
type HeifExportParams struct {
	Quality  int
	Lossless bool
}

// NewHeifExportParams creates default values for an export of a HEIF image.
func NewHeifExportParams() *HeifExportParams {
	return &HeifExportParams{
		Quality:  80,
		Lossless: false,
	}
}

// ExportHeif exports the image as HEIF to a buffer.
func (r *Image) ExportHeif(params *HeifExportParams) ([]byte, error) {
	if params == nil {
		params = NewHeifExportParams()
	}

    var buf unsafe.Pointer
    var length C.size_t

	// Call heifsave_buffer_wrapper
	err := C.heifsave_buffer_wrapper(
        r.image, &buf, &length,
		C.int(params.Quality),
		C.int(boolToInt(params.Lossless)),
	)

	if err != 0 {
		return nil, handleVipsError()
	}

    return bufferToBytes(buf, length), nil
}
{{end}}

{{if .HasTiffSaver}}
// TiffExportParams are options when exporting a TIFF to file or buffer
type TiffExportParams struct {
	StripMetadata bool
	Quality       int
	Compression   TiffCompression
	Predictor     TiffPredictor
	Pyramid       bool
	Tile          bool
	TileWidth     int
	TileHeight    int
	XRes          float64
	YRes          float64
}

// NewTiffExportParams creates default values for an export of a TIFF image.
func NewTiffExportParams() *TiffExportParams {
	return &TiffExportParams{
		Quality:     80,
		Compression: TiffCompressionLzw,
		Predictor:   TiffPredictorHorizontal,
		TileWidth:   256,
		TileHeight:  256,
		XRes:        1.0,
		YRes:        1.0,
	}
}

// ExportTiff exports the image as TIFF to a buffer.
func (r *Image) ExportTiff(params *TiffExportParams) ([]byte, error) {
	if params == nil {
		params = NewTiffExportParams()
	}

    var buf unsafe.Pointer
    var length C.size_t

	// Call tiffsave_buffer_wrapper
	err := C.tiffsave_buffer_wrapper(
        r.image, &buf, &length,
		C.int(params.Quality),
		C.int(boolToInt(params.StripMetadata)),
		C.int(params.Compression),
		C.int(params.Predictor),
		C.int(boolToInt(params.Pyramid)),
		C.int(boolToInt(params.Tile)),
		C.int(params.TileWidth),
		C.int(params.TileHeight),
		C.double(params.XRes),
		C.double(params.YRes),
	)

	if err != 0 {
		return nil, handleVipsError()
	}

    return bufferToBytes(buf, length), nil
}
{{end}}

{{if or .HasLegacyGifSaver .HasCgifSaver}}
// GifExportParams are options when exporting a GIF to file or buffer.
type GifExportParams struct {
	StripMetadata bool
	Quality       int
	Dither        float64
	Effort        int
	Bitdepth      int
}

// NewGifExportParams creates default values for an export of a GIF image.
func NewGifExportParams() *GifExportParams {
	return &GifExportParams{
		Quality:  75,
		Effort:   7,
		Bitdepth: 8,
	}
}

// ExportGif exports the image as GIF to a buffer.
func (r *Image) ExportGif(params *GifExportParams) ([]byte, error) {
	if params == nil {
		params = NewGifExportParams()
	}

    var err C.int
    var buf unsafe.Pointer
    var length C.size_t

	{{if .HasCgifSaver}}
	// Try CGIF first (available in libvips 8.12+)
	err = C.gifsave_buffer_wrapper(
        r.image, &buf, &length,
		C.double(params.Dither),
		C.int(params.Effort),
		C.int(params.Bitdepth),
	)
	{{end}}

	{{if and .HasCgifSaver .HasLegacyGifSaver}}
	// If error, try magick-based GIF
	if err != 0 {
		errorMsg := C.GoString(C.vips_error_buffer())
		C.vips_error_clear()

		// If the error is about the operator not existing, try magick
		if strings.Contains(errorMsg, "no such operator") {
			// Format is GIF for magicksave
			gifFormat := C.CString("GIF")
			defer C.free(unsafe.Pointer(gifFormat))

			err = C.magicksave_buffer_wrapper(
                r.image, &buf, &length,
				gifFormat,
				C.int(params.Quality),
			)

			if err != 0 {
				return nil, handleVipsError()
			}
		} else {
			return nil, fmt.Errorf("error saving GIF: %s", errorMsg)
		}
	}
	{{else if .HasLegacyGifSaver}}
	// Use magick-based GIF
	gifFormat := C.CString("GIF")
	defer C.free(unsafe.Pointer(gifFormat))

	err = C.magicksave_buffer_wrapper(
		r.image, &blob,
		gifFormat,
		C.int(params.Quality),
	)

	if err != 0 {
		return nil, handleVipsError()
	}
	{{end}}

    return bufferToBytes(buf, length), nil
}
{{end}}

{{if .HasAvifSaver}}
// AvifExportParams are options when exporting an AVIF to file or buffer.
type AvifExportParams struct {
	StripMetadata bool
	Quality       int
	Lossless      bool
	Speed         int
}

// NewAvifExportParams creates default values for an export of an AVIF image.
func NewAvifExportParams() *AvifExportParams {
	return &AvifExportParams{
		Quality:  80,
		Lossless: false,
		Speed:    5,
	}
}

// ExportAvif exports the image as AVIF to a buffer.
func (r *Image) ExportAvif(params *AvifExportParams) ([]byte, error) {
	if params == nil {
		params = NewAvifExportParams()
	}

    var buf unsafe.Pointer
    var length C.size_t

	// Call avifsave_buffer_wrapper
	err := C.avifsave_buffer_wrapper(
        r.image, &buf, &length,
		C.int(params.Quality),
		C.int(boolToInt(params.Lossless)),
		C.int(params.Speed),
		C.int(boolToInt(params.StripMetadata)),
	)

	if err != 0 {
		return nil, handleVipsError()
	}

    return bufferToBytes(buf, length), nil
}
{{end}}

{{if .HasJp2kSaver}}
// Jp2kExportParams are options when exporting an JPEG2000 to file or buffer.
type Jp2kExportParams struct {
	Quality       int
	Lossless      bool
	TileWidth     int
	TileHeight    int
	SubsampleMode Subsample
}

// NewJp2kExportParams creates default values for an export of an JPEG2000 image.
func NewJp2kExportParams() *Jp2kExportParams {
	return &Jp2kExportParams{
		Quality:    80,
		Lossless:   false,
		TileWidth:  512,
		TileHeight: 512,
	}
}

// ExportJp2k exports the image as JPEG2000 to a buffer.
func (r *Image) ExportJp2k(params *Jp2kExportParams) ([]byte, error) {
	if params == nil {
		params = NewJp2kExportParams()
	}

    var buf unsafe.Pointer
    var length C.size_t

	// Call jp2ksave_buffer_wrapper
	err := C.jp2ksave_buffer_wrapper(
        r.image, &buf, &length,
		C.int(params.Quality),
		C.int(boolToInt(params.Lossless)),
		C.int(params.TileWidth),
		C.int(params.TileHeight),
		C.int(params.SubsampleMode),
	)

	if err != 0 {
		return nil, handleVipsError()
	}

    return bufferToBytes(buf, length), nil
}
{{end}}

// bufferToBytes converts a C buffer to Go bytes and frees the original buffer.
// This function takes ownership of the buffer and will free it after conversion.
func bufferToBytes(buf unsafe.Pointer, length C.size_t) []byte {
    if buf == nil {
        return nil
    }

    // Convert to Go bytes (makes a copy)
    bytes := C.GoBytes(buf, C.int(length))

    // Free the original buffer allocated by libvips
    C.g_free(C.gpointer(buf))

    return bytes
}
