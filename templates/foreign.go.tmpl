// Code generated by github.com/cshum/vipsgen. DO NOT EDIT.

package vips

// #include "foreign.h"
import "C"
import (
	"fmt"
	"unsafe"
)

// ImageSaverSupport indicates which image savers are supported in this libvips build
var ImageSaverSupport = map[ImageType]bool{
	{{range .SupportedSavers}}{{.EnumName}}: true,
	{{end}}
}

{{if .HasJpegSaver}}
// JpegExportParams are options when exporting a JPEG to file or buffer
type JpegExportParams struct {
	StripMetadata      bool
	Quality            int
	Interlace          bool
	OptimizeCoding     bool
	SubsampleMode      Subsample
	TrellisQuant       bool
	OvershootDeringing bool
	OptimizeScans      bool
	QuantTable         int
}

// NewJpegExportParams creates default values for an export of a JPEG image.
// By default, vips creates interlaced JPEGs with a quality of 80/100.
func NewJpegExportParams() *JpegExportParams {
	return &JpegExportParams{
		Quality:   80,
		Interlace: true,
	}
}

// ExportJpeg exports the image as JPEG to a buffer.
func (r *Image) ExportJpeg(params *JpegExportParams) ([]byte, error) {
	if params == nil {
		params = NewJpegExportParams()
	}

	p := C.create_save_params(C.JPEG)
	p.inputImage = r.image
	p.stripMetadata = C.int(boolToInt(params.StripMetadata))
	p.quality = C.int(params.Quality)
	p.interlace = C.int(boolToInt(params.Interlace))
	p.jpegOptimizeCoding = C.int(boolToInt(params.OptimizeCoding))
	p.jpegSubsample = C.VipsForeignJpegSubsample(params.SubsampleMode)
	p.jpegTrellisQuant = C.int(boolToInt(params.TrellisQuant))
	p.jpegOvershootDeringing = C.int(boolToInt(params.OvershootDeringing))
	p.jpegOptimizeScans = C.int(boolToInt(params.OptimizeScans))
	p.jpegQuantTable = C.int(params.QuantTable)

	return vipsSaveToBuffer(p)
}
{{end}}

{{if .HasPngSaver}}
// PngExportParams are options when exporting a PNG to file or buffer
type PngExportParams struct {
	StripMetadata bool
	Compression   int
	//Filter        PngFilter
	Interlace bool
	Quality   int
	Palette   bool
	Dither    float64
	Bitdepth  int
	Profile   string // TODO: Use this param during save
}

// NewPngExportParams creates default values for an export of a PNG image.
// By default, vips creates non-interlaced PNGs with a compression of 6/10.
func NewPngExportParams() *PngExportParams {
	return &PngExportParams{
		Compression: 6,
		//Filter:      PngFilterNone,
		Interlace: false,
		Palette:   false,
	}
}

// ExportPng exports the image as PNG to a buffer.
func (r *Image) ExportPng(params *PngExportParams) ([]byte, error) {
	if params == nil {
		params = NewPngExportParams()
	}

	p := C.create_save_params(C.PNG)
	p.inputImage = r.image
	p.quality = C.int(params.Quality)
	p.stripMetadata = C.int(boolToInt(params.StripMetadata))
	p.interlace = C.int(boolToInt(params.Interlace))
	p.pngCompression = C.int(params.Compression)
	//p.pngFilter = C.VipsForeignPngFilter(params.Filter)
	p.pngPalette = C.int(boolToInt(params.Palette))
	p.pngDither = C.double(params.Dither)
	p.pngBitdepth = C.int(params.Bitdepth)

	return vipsSaveToBuffer(p)
}
{{end}}

{{if .HasWebpSaver}}
// WebpExportParams are options when exporting a WEBP to file or buffer
type WebpExportParams struct {
	StripMetadata   bool
	Quality         int
	Lossless        bool
	NearLossless    bool
	ReductionEffort int
	IccProfile      string
}

// NewWebpExportParams creates default values for an export of a WEBP image.
// By default, vips creates lossy images with a quality of 75/100.
func NewWebpExportParams() *WebpExportParams {
	return &WebpExportParams{
		Quality:         75,
		Lossless:        false,
		NearLossless:    false,
		ReductionEffort: 4,
	}
}

// ExportWebp exports the image as WEBP to a buffer.
func (r *Image) ExportWebp(params *WebpExportParams) ([]byte, error) {
	if params == nil {
		params = NewWebpExportParams()
	}

	p := C.create_save_params(C.WEBP)
	p.inputImage = r.image
	p.stripMetadata = C.int(boolToInt(params.StripMetadata))
	p.quality = C.int(params.Quality)
	p.webpLossless = C.int(boolToInt(params.Lossless))
	p.webpNearLossless = C.int(boolToInt(params.NearLossless))
	p.webpReductionEffort = C.int(params.ReductionEffort)

	if params.IccProfile != "" {
		p.webpIccProfile = C.CString(params.IccProfile)
		defer C.free(unsafe.Pointer(p.webpIccProfile))
	}

	return vipsSaveToBuffer(p)
}
{{end}}

{{if .HasHeifSaver}}
// HeifExportParams are options when exporting a HEIF to file or buffer
type HeifExportParams struct {
	Quality  int
	Lossless bool
}

// NewHeifExportParams creates default values for an export of a HEIF image.
func NewHeifExportParams() *HeifExportParams {
	return &HeifExportParams{
		Quality:  80,
		Lossless: false,
	}
}

// ExportHeif exports the image as HEIF to a buffer.
func (r *Image) ExportHeif(params *HeifExportParams) ([]byte, error) {
	if params == nil {
		params = NewHeifExportParams()
	}

	p := C.create_save_params(C.HEIF)
	p.inputImage = r.image
	p.outputFormat = C.HEIF
	p.quality = C.int(params.Quality)
	p.heifLossless = C.int(boolToInt(params.Lossless))

	return vipsSaveToBuffer(p)
}
{{end}}

{{if .HasTiffSaver}}
// TiffExportParams are options when exporting a TIFF to file or buffer
type TiffExportParams struct {
	StripMetadata bool
	Quality       int
	Compression   TiffCompression
	Predictor     TiffPredictor
}

// NewTiffExportParams creates default values for an export of a TIFF image.
func NewTiffExportParams() *TiffExportParams {
	return &TiffExportParams{
		Quality:     80,
		Compression: TiffCompressionLzw,
		Predictor:   TiffPredictorHorizontal,
	}
}

// ExportTiff exports the image as TIFF to a buffer.
func (r *Image) ExportTiff(params *TiffExportParams) ([]byte, error) {
	if params == nil {
		params = NewTiffExportParams()
	}

	p := C.create_save_params(C.TIFF)
	p.inputImage = r.image
	p.stripMetadata = C.int(boolToInt(params.StripMetadata))
	p.quality = C.int(params.Quality)
	p.tiffCompression = C.VipsForeignTiffCompression(params.Compression)

	return vipsSaveToBuffer(p)
}
{{end}}

{{if or .HasLegacyGifSaver .HasCgifSaver}}
// GifExportParams are options when exporting a GIF to file or buffer.
type GifExportParams struct {
	StripMetadata bool
	Quality       int
	Dither        float64
	Effort        int
	Bitdepth      int
}

// NewGifExportParams creates default values for an export of a GIF image.
func NewGifExportParams() *GifExportParams {
	return &GifExportParams{
		Quality:  75,
		Effort:   7,
		Bitdepth: 8,
	}
}

// ExportGIF exports the image as GIF to a buffer.
func (r *Image) ExportGIF(params *GifExportParams) ([]byte, error) {
	if params == nil {
		params = NewGifExportParams()
	}

	p := C.create_save_params(C.GIF)
	p.inputImage = r.image
	p.quality = C.int(params.Quality)
	p.stripMetadata = C.int(boolToInt(params.StripMetadata))
	p.gifDither = C.double(params.Dither)
	p.gifEffort = C.int(params.Effort)
	p.gifBitdepth = C.int(params.Bitdepth)

	return vipsSaveToBuffer(p)
}
{{end}}

{{if .HasAvifSaver}}
// AvifExportParams are options when exporting an AVIF to file or buffer.
type AvifExportParams struct {
	StripMetadata bool
	Quality       int
	Lossless      bool
	Speed         int
}

// NewAvifExportParams creates default values for an export of an AVIF image.
func NewAvifExportParams() *AvifExportParams {
	return &AvifExportParams{
		Quality:  80,
		Lossless: false,
		Speed:    5,
	}
}

// ExportAvif exports the image as AVIF to a buffer.
func (r *Image) ExportAvif(params *AvifExportParams) ([]byte, error) {
	if params == nil {
		params = NewAvifExportParams()
	}

	p := C.create_save_params(C.AVIF)
	p.inputImage = r.image
	p.outputFormat = C.AVIF
	p.quality = C.int(params.Quality)
	p.stripMetadata = C.int(boolToInt(params.StripMetadata))
	p.heifLossless = C.int(boolToInt(params.Lossless))
	p.avifSpeed = C.int(params.Speed)

	return vipsSaveToBuffer(p)
}
{{end}}

{{if .HasJp2kSaver}}
// Jp2kExportParams are options when exporting an JPEG2000 to file or buffer.
type Jp2kExportParams struct {
	Quality       int
	Lossless      bool
	TileWidth     int
	TileHeight    int
	SubsampleMode Subsample
}

// NewJp2kExportParams creates default values for an export of an JPEG2000 image.
func NewJp2kExportParams() *Jp2kExportParams {
	return &Jp2kExportParams{
		Quality:    80,
		Lossless:   false,
		TileWidth:  512,
		TileHeight: 512,
	}
}

// ExportJp2k exports the image as JPEG2000 to a buffer.
func (r *Image) ExportJp2k(params *Jp2kExportParams) ([]byte, error) {
	if params == nil {
		params = NewJp2kExportParams()
	}

	p := C.create_save_params(C.JP2K)
	p.inputImage = r.image
	p.outputFormat = C.JP2K
	p.quality = C.int(params.Quality)
	p.jp2kLossless = C.int(boolToInt(params.Lossless))
	p.jp2kTileWidth = C.int(params.TileWidth)
	p.jp2kTileHeight = C.int(params.TileHeight)
	p.jpegSubsample = C.VipsForeignJpegSubsample(params.SubsampleMode)

	return vipsSaveToBuffer(p)
}
{{end}}

// Export exports the image to a buffer in the specified format
func (r *Image) Export(format ImageType, options interface{}) ([]byte, error) {
	if !ImageSaverSupport[format] {
		return nil, fmt.Errorf("format %s export not supported in this libvips build",
			ImageTypes[format])
	}

	switch format {
	{{if .HasJpegSaver}}
	case ImageTypeJpeg:
		var params *JpegExportParams
		if options != nil {
			if p, ok := options.(*JpegExportParams); ok {
				params = p
			}
		}
		return r.ExportJpeg(params)
	{{end}}
	{{if .HasPngSaver}}
	case ImageTypePng:
		var params *PngExportParams
		if options != nil {
			if p, ok := options.(*PngExportParams); ok {
				params = p
			}
		}
		return r.ExportPng(params)
	{{end}}
	{{if .HasWebpSaver}}
	case ImageTypeWebp:
		var params *WebpExportParams
		if options != nil {
			if p, ok := options.(*WebpExportParams); ok {
				params = p
			}
		}
		return r.ExportWebp(params)
	{{end}}
	{{if .HasHeifSaver}}
	case ImageTypeHeif:
		var params *HeifExportParams
		if options != nil {
			if p, ok := options.(*HeifExportParams); ok {
				params = p
			}
		}
		return r.ExportHeif(params)
	{{end}}
	{{if .HasTiffSaver}}
	case ImageTypeTiff:
		var params *TiffExportParams
		if options != nil {
			if p, ok := options.(*TiffExportParams); ok {
				params = p
			}
		}
		return r.ExportTiff(params)
	{{end}}
	{{if or .HasLegacyGifSaver .HasCgifSaver}}
	case ImageTypeGif:
		var params *GifExportParams
		if options != nil {
			if p, ok := options.(*GifExportParams); ok {
				params = p
			}
		}
		return r.ExportGIF(params)
	{{end}}
	{{if .HasAvifSaver}}
	case ImageTypeAvif:
		var params *AvifExportParams
		if options != nil {
			if p, ok := options.(*AvifExportParams); ok {
				params = p
			}
		}
		return r.ExportAvif(params)
	{{end}}
	{{if .HasJp2kSaver}}
	case ImageTypeJp2k:
		var params *Jp2kExportParams
		if options != nil {
			if p, ok := options.(*Jp2kExportParams); ok {
				params = p
			}
		}
		return r.ExportJp2k(params)
	{{end}}
	default:
		return nil, fmt.Errorf("unsupported image format for export: %s",
			ImageTypes[format])
	}
}

func vipsSaveToBuffer(params C.struct_SaveParams) ([]byte, error) {
	if err := C.save_to_buffer(&params); err != 0 {
		if params.outputBuffer != nil {
			gFreePointer(params.outputBuffer)
		}
		return nil, handleVipsError()
	}

	buf := C.GoBytes(params.outputBuffer, C.int(params.outputLen))
	defer gFreePointer(params.outputBuffer)

	return buf, nil
}
