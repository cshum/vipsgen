// Code generated by github.com/cshum/vipsgen. DO NOT EDIT.

package vips

// #include "foreign.h"
import "C"
import (
	"unsafe"
)

{{if .HasJpegSaver}}
// SaveJpegParams are options when exporting a JPEG to file or buffer
type SaveJpegParams struct {
	StripMetadata      bool
	Quality            int
	Interlace          bool
	OptimizeCoding     bool
	SubsampleMode      Subsample
	TrellisQuant       bool
	OvershootDeringing bool
	OptimizeScans      bool
	QuantTable         int
}

// NewSaveJpegParams creates default values for an export of a JPEG image.
// By default, vips creates interlaced JPEGs with a quality of 80/100.
func NewSaveJpegParams() *SaveJpegParams {
	return &SaveJpegParams{
		Quality:   80,
		Interlace: true,
	}
}

// SaveJpegBuffer exports the image as JPEG to a buffer.
func (r *Image) SaveJpegBuffer(params *SaveJpegParams) ([]byte, error) {
    if params == nil {
        params = NewSaveJpegParams()
    }
    var buf unsafe.Pointer
    var length C.size_t

    err := C.vipsgen_jpegsave_buffer(
        r.image, &buf, &length,
        C.int(params.Quality),
        C.int(boolToInt(params.StripMetadata)),
        C.int(boolToInt(params.OptimizeCoding)),
        C.int(boolToInt(params.Interlace)),
        C.int(params.SubsampleMode),
        C.int(boolToInt(params.TrellisQuant)),
        C.int(boolToInt(params.OvershootDeringing)),
        C.int(boolToInt(params.OptimizeScans)),
        C.int(params.QuantTable))
    if err != 0 {
        return nil, handleVipsError()
    }
    return bufferToBytes(buf, length), nil
}

// SaveJpegFile exports the image as JPEG to a file.
func (r *Image) SaveJpegFile(filename string, params *SaveJpegParams) error {
    if params == nil {
        params = NewSaveJpegParams()
    }
    cFilename := C.CString(filename)
    defer freeCString(cFilename)

    err := C.vipsgen_jpegsave_file(
        r.image, cFilename,
        C.int(params.Quality),
        C.int(boolToInt(params.StripMetadata)),
        C.int(boolToInt(params.OptimizeCoding)),
        C.int(boolToInt(params.Interlace)),
        C.int(params.SubsampleMode),
        C.int(boolToInt(params.TrellisQuant)),
        C.int(boolToInt(params.OvershootDeringing)),
        C.int(boolToInt(params.OptimizeScans)),
        C.int(params.QuantTable))
    if err != 0 {
        return handleVipsError()
    }
    return nil
}
{{end}}

{{if .HasPngSaver}}
// SavePngParams are options when exporting a PNG to file or buffer
type SavePngParams struct {
	StripMetadata bool
	Compression   int
	Interlace     bool
	Quality       int
	Palette       bool
	Dither        float64
	Bitdepth      int
	Filter        PngFilter
}

// NewSavePngParams creates default values for an export of a PNG image.
// By default, vips creates non-interlaced PNGs with a compression of 6/10.
func NewSavePngParams() *SavePngParams {
	return &SavePngParams{
		Compression: 6,
		Interlace:   false,
		Palette:     false,
		Filter:      PngFilterNone,
	}
}

// SavePngBuffer exports the image as PNG to a buffer.
func (r *Image) SavePngBuffer(params *SavePngParams) ([]byte, error) {
	if params == nil {
		params = NewSavePngParams()
	}
    var buf unsafe.Pointer
    var length C.size_t

	err := C.vipsgen_pngsave_buffer(
        r.image, &buf, &length,
		C.int(params.Compression),
		C.int(boolToInt(params.StripMetadata)),
		C.int(boolToInt(params.Interlace)),
		C.int(params.Filter),
		C.int(boolToInt(params.Palette)),
		C.int(params.Quality),
		C.double(params.Dither),
		C.int(params.Bitdepth))
	if err != 0 {
		return nil, handleVipsError()
	}
    return bufferToBytes(buf, length), nil
}

// SavePngFile exports the image as PNG to a file.
func (r *Image) SavePngFile(filename string, params *SavePngParams) error {
	if params == nil {
		params = NewSavePngParams()
	}
    cFilename := C.CString(filename)
    defer freeCString(cFilename)

	err := C.vipsgen_pngsave_file(
        r.image, cFilename,
		C.int(params.Compression),
		C.int(boolToInt(params.StripMetadata)),
		C.int(boolToInt(params.Interlace)),
		C.int(params.Filter),
		C.int(boolToInt(params.Palette)),
		C.int(params.Quality),
		C.double(params.Dither),
		C.int(params.Bitdepth))
	if err != 0 {
		return handleVipsError()
	}
    return nil
}
{{end}}

{{if .HasWebpSaver}}
// SaveWebpParams are options when exporting a WEBP to file or buffer
type SaveWebpParams struct {
	StripMetadata   bool
	Quality         int
	Lossless        bool
	NearLossless    bool
	ReductionEffort int
	IccProfile      string
}

// NewSaveWebpParams creates default values for an export of a WEBP image.
// By default, vips creates lossy images with a quality of 75/100.
func NewSaveWebpParams() *SaveWebpParams {
	return &SaveWebpParams{
		Quality:         75,
		Lossless:        false,
		NearLossless:    false,
		ReductionEffort: 4,
	}
}

// SaveWebpBuffer exports the image as WEBP to a buffer.
func (r *Image) SaveWebpBuffer(params *SaveWebpParams) ([]byte, error) {
	if params == nil {
		params = NewSaveWebpParams()
	}
    var err C.int
    var buf unsafe.Pointer
    var length C.size_t

	if params.IccProfile != "" {
		cProfile := C.CString(params.IccProfile)
		defer C.free(unsafe.Pointer(cProfile))

		err = C.vipsgen_webpsave_buffer_profile(
            r.image, &buf, &length,
			C.int(params.Quality),
			C.int(boolToInt(params.StripMetadata)),
			C.int(boolToInt(params.Lossless)),
			C.int(boolToInt(params.NearLossless)),
			C.int(params.ReductionEffort),
			cProfile)
	} else {
		err = C.vipsgen_webpsave_buffer(
            r.image, &buf, &length,
			C.int(params.Quality),
			C.int(boolToInt(params.StripMetadata)),
			C.int(boolToInt(params.Lossless)),
			C.int(boolToInt(params.NearLossless)),
			C.int(params.ReductionEffort))
	}
	if err != 0 {
		return nil, handleVipsError()
	}
    return bufferToBytes(buf, length), nil
}

// SaveWebpFile exports the image as WEBP to a file.
func (r *Image) SaveWebpFile(filename string, params *SaveWebpParams) error {
	if params == nil {
		params = NewSaveWebpParams()
	}
    cFilename := C.CString(filename)
    defer freeCString(cFilename)

	var err C.int
	if params.IccProfile != "" {
		cProfile := C.CString(params.IccProfile)
		defer C.free(unsafe.Pointer(cProfile))

		err = C.vipsgen_webpsave_file_profile(
            r.image, cFilename,
			C.int(params.Quality),
			C.int(boolToInt(params.StripMetadata)),
			C.int(boolToInt(params.Lossless)),
			C.int(boolToInt(params.NearLossless)),
			C.int(params.ReductionEffort),
			cProfile)
	} else {
		err = C.vipsgen_webpsave_file(
            r.image, cFilename,
			C.int(params.Quality),
			C.int(boolToInt(params.StripMetadata)),
			C.int(boolToInt(params.Lossless)),
			C.int(boolToInt(params.NearLossless)),
			C.int(params.ReductionEffort))
	}

	if err != 0 {
		return handleVipsError()
	}
    return nil
}
{{end}}

{{if .HasHeifSaver}}
// SaveHeifParams are options when exporting a HEIF to file or buffer
type SaveHeifParams struct {
	Quality  int
	Lossless bool
}

// NewSaveHeifParams creates default values for an export of a HEIF image.
func NewSaveHeifParams() *SaveHeifParams {
	return &SaveHeifParams{
		Quality:  80,
		Lossless: false,
	}
}

// SaveHeifBuffer exports the image as HEIF to a buffer.
func (r *Image) SaveHeifBuffer(params *SaveHeifParams) ([]byte, error) {
	if params == nil {
		params = NewSaveHeifParams()
	}
    var buf unsafe.Pointer
    var length C.size_t

	err := C.vipsgen_heifsave_buffer(
        r.image, &buf, &length,
		C.int(params.Quality),
		C.int(boolToInt(params.Lossless)))
	if err != 0 {
		return nil, handleVipsError()
	}
    return bufferToBytes(buf, length), nil
}

// SaveHeifFile exports the image as HEIF to a file.
func (r *Image) SaveHeifFile(filename string, params *SaveHeifParams) error {
	if params == nil {
		params = NewSaveHeifParams()
	}
    cFilename := C.CString(filename)
    defer freeCString(cFilename)

	err := C.vipsgen_heifsave_file(
		r.image, cFilename,
		C.int(params.Quality),
		C.int(boolToInt(params.Lossless)))
	if err != 0 {
		return handleVipsError()
	}
    return nil
}
{{end}}

{{if .HasTiffSaver}}
// SaveTiffParams are options when exporting a TIFF to file or buffer
type SaveTiffParams struct {
	StripMetadata bool
	Quality       int
	Compression   TiffCompression
	Predictor     TiffPredictor
	Pyramid       bool
	Tile          bool
	TileWidth     int
	TileHeight    int
	XRes          float64
	YRes          float64
}

// NewSaveTiffParams creates default values for an export of a TIFF image.
func NewSaveTiffParams() *SaveTiffParams {
	return &SaveTiffParams{
		Quality:     80,
		Compression: TiffCompressionLzw,
		Predictor:   TiffPredictorHorizontal,
		TileWidth:   256,
		TileHeight:  256,
		XRes:        1.0,
		YRes:        1.0,
	}
}

// SaveTiffBuffer exports the image as TIFF to a buffer.
func (r *Image) SaveTiffBuffer(params *SaveTiffParams) ([]byte, error) {
	if params == nil {
		params = NewSaveTiffParams()
	}
    var buf unsafe.Pointer
    var length C.size_t

	// Call vipsgen_tiffsave_buffer
	err := C.vipsgen_tiffsave_buffer(
        r.image, &buf, &length,
		C.int(params.Quality),
		C.int(boolToInt(params.StripMetadata)),
		C.int(params.Compression),
		C.int(params.Predictor),
		C.int(boolToInt(params.Pyramid)),
		C.int(boolToInt(params.Tile)),
		C.int(params.TileWidth),
		C.int(params.TileHeight),
		C.double(params.XRes),
		C.double(params.YRes))
	if err != 0 {
		return nil, handleVipsError()
	}
    return bufferToBytes(buf, length), nil
}

// SaveTiffFile exports the image as TIFF to a file.
func (r *Image) SaveTiffFile(filename string, params *SaveTiffParams) error {
	if params == nil {
		params = NewSaveTiffParams()
	}
    cFilename := C.CString(filename)
    defer freeCString(cFilename)

	err := C.vipsgen_tiffsave_file(
		r.image, cFilename,
		C.int(params.Quality),
		C.int(boolToInt(params.StripMetadata)),
		C.int(params.Compression),
		C.int(params.Predictor),
		C.int(boolToInt(params.Pyramid)),
		C.int(boolToInt(params.Tile)),
		C.int(params.TileWidth),
		C.int(params.TileHeight),
		C.double(params.XRes),
		C.double(params.YRes))
	if err != 0 {
		return handleVipsError()
	}
    return nil
}
{{end}}

{{if or .HasLegacyGifSaver .HasCgifSaver}}
// SaveGifParams are options when exporting a GIF to file or buffer.
type SaveGifParams struct {
	StripMetadata bool
	Quality       int
	Dither        float64
	Effort        int
	Bitdepth      int
}

// NewSaveGifParams creates default values for an export of a GIF image.
func NewSaveGifParams() *SaveGifParams {
	return &SaveGifParams{
		Quality:  75,
		Effort:   7,
		Bitdepth: 8,
	}
}

// SaveGifBuffer exports the image as GIF to a buffer.
func (r *Image) SaveGifBuffer(params *SaveGifParams) ([]byte, error) {
	if params == nil {
		params = NewSaveGifParams()
	}
    var err C.int
    var buf unsafe.Pointer
    var length C.size_t

	{{if .HasCgifSaver}}
	// Try CGIF first (available in libvips 8.12+)
	err = C.vipsgen_gifsave_buffer(
        r.image, &buf, &length,
		C.double(params.Dither),
		C.int(params.Effort),
		C.int(params.Bitdepth))
	{{end}}{{if and .HasCgifSaver .HasLegacyGifSaver}}
	// If error, try magick-based GIF
	if err != 0 {
		C.vips_error_clear()

        gifFormat := C.CString("GIF")
        defer C.free(unsafe.Pointer(gifFormat))

        err = C.vipsgen_magicksave_buffer(
            r.image, &buf, &length,
            gifFormat,
            C.int(params.Quality))
        if err != 0 {
            return nil, handleVipsError()
        }
	}
	{{else if .HasLegacyGifSaver}}
	// Use magick-based GIF
	gifFormat := C.CString("GIF")
	defer C.free(unsafe.Pointer(gifFormat))

	err = C.vipsgen_magicksave_buffer(
		r.image, &buf, &length,
		gifFormat,
		C.int(params.Quality))
	if err != 0 {
		return nil, handleVipsError()
	}
	{{end}}
    return bufferToBytes(buf, length), nil
}

// SaveGifFile exports the image as GIF to a file.
func (r *Image) SaveGifFile(filename string, params *SaveGifParams) error {
	if params == nil {
		params = NewSaveGifParams()
	}
    cFilename := C.CString(filename)
    defer freeCString(cFilename)

	var err C.int
	{{if .HasCgifSaver}}
	// Try CGIF first (available in libvips 8.12+)
	err = C.vipsgen_gifsave_file(
		r.image, cFilename,
		C.double(params.Dither),
		C.int(params.Effort),
		C.int(params.Bitdepth))
	{{end}}{{if and .HasCgifSaver .HasLegacyGifSaver}}
	// If error, try magick-based GIF
	if err != 0 {
		C.vips_error_clear()

        gifFormat := C.CString("GIF")
        defer C.free(unsafe.Pointer(gifFormat))

        err = C.vipsgen_magicksave_file(
            r.image, cFilename,
            gifFormat,
            C.int(params.Quality))
        if err != 0 {
            return handleVipsError()
        }
	}
	{{else if .HasLegacyGifSaver}}
	// Use magick-based GIF
	gifFormat := C.CString("GIF")
	defer C.free(unsafe.Pointer(gifFormat))

	err = C.vipsgen_magicksave_file(
		r.image, cFilename,
		gifFormat,
		C.int(params.Quality))
	if err != 0 {
		return handleVipsError()
	}
	{{end}}
    return nil
}
{{end}}

{{if .HasAvifSaver}}
// SaveAvifParams are options when exporting an AVIF to file or buffer.
type SaveAvifParams struct {
	StripMetadata bool
	Quality       int
	Lossless      bool
	Speed         int
}

// NewSaveAvifParams creates default values for an export of an AVIF image.
func NewSaveAvifParams() *SaveAvifParams {
	return &SaveAvifParams{
		Quality:  80,
		Lossless: false,
		Speed:    5,
	}
}

// SaveAvifBuffer exports the image as AVIF to a buffer.
func (r *Image) SaveAvifBuffer(params *SaveAvifParams) ([]byte, error) {
	if params == nil {
		params = NewSaveAvifParams()
	}
    var buf unsafe.Pointer
    var length C.size_t

	err := C.vipsgen_avifsave_buffer(
        r.image, &buf, &length,
		C.int(params.Quality),
		C.int(boolToInt(params.Lossless)),
		C.int(params.Speed),
		C.int(boolToInt(params.StripMetadata)))
	if err != 0 {
		return nil, handleVipsError()
	}
    return bufferToBytes(buf, length), nil
}

// SaveAvifFile exports the image as AVIF to a file.
func (r *Image) SaveAvifFile(filename string, params *SaveAvifParams) error {
	if params == nil {
		params = NewSaveAvifParams()
	}
    cFilename := C.CString(filename)
    defer freeCString(cFilename)

	err := C.vipsgen_avifsave_file(
		r.image, cFilename,
		C.int(params.Quality),
		C.int(boolToInt(params.Lossless)),
		C.int(params.Speed),
		C.int(boolToInt(params.StripMetadata)))
	if err != 0 {
		return handleVipsError()
	}
    return nil
}
{{end}}

{{if .HasJp2kSaver}}
// SaveJp2kParams are options when exporting an JPEG2000 to file or buffer.
type SaveJp2kParams struct {
	Quality       int
	Lossless      bool
	TileWidth     int
	TileHeight    int
	SubsampleMode Subsample
}

// NewSaveJp2kParams creates default values for an export of an JPEG2000 image.
func NewSaveJp2kParams() *SaveJp2kParams {
	return &SaveJp2kParams{
		Quality:    80,
		Lossless:   false,
		TileWidth:  512,
		TileHeight: 512,
	}
}

// SaveJp2kBuffer exports the image as JPEG2000 to a buffer.
func (r *Image) SaveJp2kBuffer(params *SaveJp2kParams) ([]byte, error) {
	if params == nil {
		params = NewSaveJp2kParams()
	}
    var buf unsafe.Pointer
    var length C.size_t

	err := C.vipsgen_jp2ksave_buffer(
        r.image, &buf, &length,
		C.int(params.Quality),
		C.int(boolToInt(params.Lossless)),
		C.int(params.TileWidth),
		C.int(params.TileHeight),
		C.int(params.SubsampleMode))
	if err != 0 {
		return nil, handleVipsError()
	}
    return bufferToBytes(buf, length), nil
}

// SaveJp2kFile exports the image as JPEG2000 to a file.
func (r *Image) SaveJp2kFile(filename string, params *SaveJp2kParams) error {
	if params == nil {
		params = NewSaveJp2kParams()
	}
    cFilename := C.CString(filename)
    defer freeCString(cFilename)

	err := C.vipsgen_jp2ksave_file(
		r.image, cFilename,
		C.int(params.Quality),
		C.int(boolToInt(params.Lossless)),
		C.int(params.TileWidth),
		C.int(params.TileHeight),
		C.int(params.SubsampleMode))
	if err != 0 {
		return handleVipsError()
	}
    return nil
}
{{end}}
