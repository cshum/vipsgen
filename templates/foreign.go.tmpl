// Code generated by github.com/cshum/vipsgen. DO NOT EDIT.

package vips

// #include "foreign.h"
import "C"
import (
	"unsafe"
)

{{if .HasJpegSaver}}
// JpegSaveParams are options when exporting a JPEG to file or buffer
type JpegSaveParams struct {
	StripMetadata      bool
	Quality            int
	Interlace          bool
	OptimizeCoding     bool
	SubsampleMode      Subsample
	TrellisQuant       bool
	OvershootDeringing bool
	OptimizeScans      bool
	QuantTable         int
}

// NewJpegSaveParams creates default values for an export of a JPEG image.
// By default, vips creates interlaced JPEGs with a quality of 80/100.
func NewJpegSaveParams() *JpegSaveParams {
	return &JpegSaveParams{
		Quality:   80,
		Interlace: true,
	}
}

// JpegSaveBuffer exports the image as JPEG to a buffer.
func (r *Image) JpegSaveBuffer(params *JpegSaveParams) ([]byte, error) {
    if params == nil {
        params = NewJpegSaveParams()
    }
    var buf unsafe.Pointer
    var length C.size_t

    err := C.vipsgen_jpegsave_buffer(
        r.image, &buf, &length,
        C.int(params.Quality),
        C.int(boolToInt(params.StripMetadata)),
        C.int(boolToInt(params.OptimizeCoding)),
        C.int(boolToInt(params.Interlace)),
        C.int(params.SubsampleMode),
        C.int(boolToInt(params.TrellisQuant)),
        C.int(boolToInt(params.OvershootDeringing)),
        C.int(boolToInt(params.OptimizeScans)),
        C.int(params.QuantTable),
    )
    if err != 0 {
        return nil, handleVipsError()
    }
    return bufferToBytes(buf, length), nil
}
{{end}}

{{if .HasPngSaver}}
// PngSaveParams are options when exporting a PNG to file or buffer
type PngSaveParams struct {
	StripMetadata bool
	Compression   int
	Interlace     bool
	Quality       int
	Palette       bool
	Dither        float64
	Bitdepth      int
	Filter        PngFilter
}

// NewPngSaveParams creates default values for an export of a PNG image.
// By default, vips creates non-interlaced PNGs with a compression of 6/10.
func NewPngSaveParams() *PngSaveParams {
	return &PngSaveParams{
		Compression: 6,
		Interlace:   false,
		Palette:     false,
		Filter:      PngFilterNone,
	}
}

// PngSaveBuffer exports the image as PNG to a buffer.
func (r *Image) PngSaveBuffer(params *PngSaveParams) ([]byte, error) {
	if params == nil {
		params = NewPngSaveParams()
	}
    var buf unsafe.Pointer
    var length C.size_t

	err := C.vipsgen_pngsave_buffer(
        r.image, &buf, &length,
		C.int(params.Compression),
		C.int(boolToInt(params.StripMetadata)),
		C.int(boolToInt(params.Interlace)),
		C.int(params.Filter),
		C.int(boolToInt(params.Palette)),
		C.int(params.Quality),
		C.double(params.Dither),
		C.int(params.Bitdepth),
	)
	if err != 0 {
		return nil, handleVipsError()
	}
    return bufferToBytes(buf, length), nil
}
{{end}}

{{if .HasWebpSaver}}
// WebpSaveParams are options when exporting a WEBP to file or buffer
type WebpSaveParams struct {
	StripMetadata   bool
	Quality         int
	Lossless        bool
	NearLossless    bool
	ReductionEffort int
	IccProfile      string
}

// NewWebpSaveParams creates default values for an export of a WEBP image.
// By default, vips creates lossy images with a quality of 75/100.
func NewWebpSaveParams() *WebpSaveParams {
	return &WebpSaveParams{
		Quality:         75,
		Lossless:        false,
		NearLossless:    false,
		ReductionEffort: 4,
	}
}

// ExportWebp exports the image as WEBP to a buffer.
func (r *Image) ExportWebp(params *WebpSaveParams) ([]byte, error) {
	if params == nil {
		params = NewWebpSaveParams()
	}
    var err C.int
    var buf unsafe.Pointer
    var length C.size_t

	if params.IccProfile != "" {
		cProfile := C.CString(params.IccProfile)
		defer C.free(unsafe.Pointer(cProfile))

		err = C.vipsgen_webpsave_buffer_profile(
            r.image, &buf, &length,
			C.int(params.Quality),
			C.int(boolToInt(params.StripMetadata)),
			C.int(boolToInt(params.Lossless)),
			C.int(boolToInt(params.NearLossless)),
			C.int(params.ReductionEffort),
			cProfile,
		)
	} else {
		err = C.vipsgen_webpsave_buffer(
            r.image, &buf, &length,
			C.int(params.Quality),
			C.int(boolToInt(params.StripMetadata)),
			C.int(boolToInt(params.Lossless)),
			C.int(boolToInt(params.NearLossless)),
			C.int(params.ReductionEffort),
		)
	}
	if err != 0 {
		return nil, handleVipsError()
	}
    return bufferToBytes(buf, length), nil
}
{{end}}

{{if .HasHeifSaver}}
// HeifSaveParams are options when exporting a HEIF to file or buffer
type HeifSaveParams struct {
	Quality  int
	Lossless bool
}

// NewHeifSaveParams creates default values for an export of a HEIF image.
func NewHeifSaveParams() *HeifSaveParams {
	return &HeifSaveParams{
		Quality:  80,
		Lossless: false,
	}
}

// ExportHeif exports the image as HEIF to a buffer.
func (r *Image) ExportHeif(params *HeifSaveParams) ([]byte, error) {
	if params == nil {
		params = NewHeifSaveParams()
	}
    var buf unsafe.Pointer
    var length C.size_t

	err := C.vipsgen_heifsave_buffer(
        r.image, &buf, &length,
		C.int(params.Quality),
		C.int(boolToInt(params.Lossless)),
	)
	if err != 0 {
		return nil, handleVipsError()
	}
    return bufferToBytes(buf, length), nil
}
{{end}}

{{if .HasTiffSaver}}
// TiffSaveParams are options when exporting a TIFF to file or buffer
type TiffSaveParams struct {
	StripMetadata bool
	Quality       int
	Compression   TiffCompression
	Predictor     TiffPredictor
	Pyramid       bool
	Tile          bool
	TileWidth     int
	TileHeight    int
	XRes          float64
	YRes          float64
}

// NewTiffSaveParams creates default values for an export of a TIFF image.
func NewTiffSaveParams() *TiffSaveParams {
	return &TiffSaveParams{
		Quality:     80,
		Compression: TiffCompressionLzw,
		Predictor:   TiffPredictorHorizontal,
		TileWidth:   256,
		TileHeight:  256,
		XRes:        1.0,
		YRes:        1.0,
	}
}

// TiffSaveBuffer exports the image as TIFF to a buffer.
func (r *Image) TiffSaveBuffer(params *TiffSaveParams) ([]byte, error) {
	if params == nil {
		params = NewTiffSaveParams()
	}
    var buf unsafe.Pointer
    var length C.size_t

	// Call vipsgen_tiffsave_buffer
	err := C.vipsgen_tiffsave_buffer(
        r.image, &buf, &length,
		C.int(params.Quality),
		C.int(boolToInt(params.StripMetadata)),
		C.int(params.Compression),
		C.int(params.Predictor),
		C.int(boolToInt(params.Pyramid)),
		C.int(boolToInt(params.Tile)),
		C.int(params.TileWidth),
		C.int(params.TileHeight),
		C.double(params.XRes),
		C.double(params.YRes),
	)
	if err != 0 {
		return nil, handleVipsError()
	}
    return bufferToBytes(buf, length), nil
}
{{end}}

{{if or .HasLegacyGifSaver .HasCgifSaver}}
// GifSaveParams are options when exporting a GIF to file or buffer.
type GifSaveParams struct {
	StripMetadata bool
	Quality       int
	Dither        float64
	Effort        int
	Bitdepth      int
}

// NewGifSaveParams creates default values for an export of a GIF image.
func NewGifSaveParams() *GifSaveParams {
	return &GifSaveParams{
		Quality:  75,
		Effort:   7,
		Bitdepth: 8,
	}
}

// GifSaveBuffer exports the image as GIF to a buffer.
func (r *Image) GifSaveBuffer(params *GifSaveParams) ([]byte, error) {
	if params == nil {
		params = NewGifSaveParams()
	}
    var err C.int
    var buf unsafe.Pointer
    var length C.size_t

	{{if .HasCgifSaver}}
	// Try CGIF first (available in libvips 8.12+)
	err = C.vipsgen_gifsave_buffer(
        r.image, &buf, &length,
		C.double(params.Dither),
		C.int(params.Effort),
		C.int(params.Bitdepth),
	)
	{{end}}{{if and .HasCgifSaver .HasLegacyGifSaver}}
	// If error, try magick-based GIF
	if err != 0 {
		C.vips_error_clear()

        gifFormat := C.CString("GIF")
        defer C.free(unsafe.Pointer(gifFormat))

        err = C.vipsgen_magicksave_buffer(
            r.image, &buf, &length,
            gifFormat,
            C.int(params.Quality),
        )
        if err != 0 {
            return nil, handleVipsError()
        }
	}
	{{else if .HasLegacyGifSaver}}
	// Use magick-based GIF
	gifFormat := C.CString("GIF")
	defer C.free(unsafe.Pointer(gifFormat))

	err = C.vipsgen_magicksave_buffer(
		r.image, &blob,
		gifFormat,
		C.int(params.Quality),
	)
	if err != 0 {
		return nil, handleVipsError()
	}
	{{end}}
    return bufferToBytes(buf, length), nil
}
{{end}}

{{if .HasAvifSaver}}
// AvifSaveParams are options when exporting an AVIF to file or buffer.
type AvifSaveParams struct {
	StripMetadata bool
	Quality       int
	Lossless      bool
	Speed         int
}

// NewAvifSaveParams creates default values for an export of an AVIF image.
func NewAvifSaveParams() *AvifSaveParams {
	return &AvifSaveParams{
		Quality:  80,
		Lossless: false,
		Speed:    5,
	}
}

// AvifSaveBuffer exports the image as AVIF to a buffer.
func (r *Image) AvifSaveBuffer(params *AvifSaveParams) ([]byte, error) {
	if params == nil {
		params = NewAvifSaveParams()
	}
    var buf unsafe.Pointer
    var length C.size_t

	err := C.vipsgen_avifsave_buffer(
        r.image, &buf, &length,
		C.int(params.Quality),
		C.int(boolToInt(params.Lossless)),
		C.int(params.Speed),
		C.int(boolToInt(params.StripMetadata)),
	)
	if err != 0 {
		return nil, handleVipsError()
	}
    return bufferToBytes(buf, length), nil
}
{{end}}

{{if .HasJp2kSaver}}
// Jp2kSaveParams are options when exporting an JPEG2000 to file or buffer.
type Jp2kSaveParams struct {
	Quality       int
	Lossless      bool
	TileWidth     int
	TileHeight    int
	SubsampleMode Subsample
}

// NewJp2kSaveParams creates default values for an export of an JPEG2000 image.
func NewJp2kSaveParams() *Jp2kSaveParams {
	return &Jp2kSaveParams{
		Quality:    80,
		Lossless:   false,
		TileWidth:  512,
		TileHeight: 512,
	}
}

// Jp2kSaveBuffer exports the image as JPEG2000 to a buffer.
func (r *Image) Jp2kSaveBuffer(params *Jp2kSaveParams) ([]byte, error) {
	if params == nil {
		params = NewJp2kSaveParams()
	}
    var buf unsafe.Pointer
    var length C.size_t

	err := C.vipsgen_jp2ksave_buffer(
        r.image, &buf, &length,
		C.int(params.Quality),
		C.int(boolToInt(params.Lossless)),
		C.int(params.TileWidth),
		C.int(params.TileHeight),
		C.int(params.SubsampleMode),
	)
	if err != 0 {
		return nil, handleVipsError()
	}
    return bufferToBytes(buf, length), nil
}
{{end}}

