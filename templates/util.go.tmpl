// Code generated by github.com/cshum/vipsgen. DO NOT EDIT.

package vips

// #cgo pkg-config: vips
// #include <vips/vips.h>
// #include <vips/vector.h>
// #include <stdlib.h>
// #include <glib.h>
// #include "util.h"
import "C"
import (
	"fmt"
	"runtime"
	"sync"
	"unsafe"
)

// Version is the full libvips version string (x.y.z)
const Version = string(C.VIPS_VERSION)

// MajorVersion is the libvips major component of the version string (x in x.y.z)
const MajorVersion = int(C.VIPS_MAJOR_VERSION)

// MinorVersion is the libvips minor component of the version string (y in x.y.z)
const MinorVersion = int(C.VIPS_MINOR_VERSION)

// MicroVersion is the libvips micro component of the version string (z in x.y.z)
// Also known as patch version
const MicroVersion = int(C.VIPS_MICRO_VERSION)

var (
	lock       sync.Mutex
	once       sync.Once
	isStarted  bool
	isShutdown bool
)

type Config struct {
	ConcurrencyLevel int
	MaxCacheFiles    int
	MaxCacheMem      int
	MaxCacheSize     int
	ReportLeaks      bool
	CacheTrace       bool
	VectorEnabled    bool
}

// LogLevel log level
type LogLevel int

// LogLevel enum
const (
	LogLevelError    LogLevel = C.G_LOG_LEVEL_ERROR
	LogLevelCritical LogLevel = C.G_LOG_LEVEL_CRITICAL
	LogLevelWarning  LogLevel = C.G_LOG_LEVEL_WARNING
	LogLevelMessage  LogLevel = C.G_LOG_LEVEL_MESSAGE
	LogLevelInfo     LogLevel = C.G_LOG_LEVEL_INFO
	LogLevelDebug    LogLevel = C.G_LOG_LEVEL_DEBUG
)

var (
	currentLoggingHandlerFunction = noopLoggingHandler
	currentLoggingVerbosity       LogLevel
)

// LoggingHandlerFunction logging handler function
type LoggingHandlerFunction func(messageDomain string, messageLevel LogLevel, message string)

// SetLogging set logging handler and verbosity
func SetLogging(handler LoggingHandlerFunction, verbosity LogLevel) {
	if handler != nil {
		currentLoggingHandlerFunction = handler
	}
	currentLoggingVerbosity = verbosity
}

func noopLoggingHandler(_ string, _ LogLevel, _ string) {
}

func log(domain string, level LogLevel, message string) {
	if level <= currentLoggingVerbosity {
		currentLoggingHandlerFunction(domain, level, message)
	}
}

func enableLogging() {
	C.set_logging_handler()
}

func disableLogging() {
	C.unset_logging_handler()
}


// Startup sets up libvips with default config.
func StartupDefault() {
	Startup(nil)
}

// Startup sets up libvips and ensures the versions are correct. Pass in nil for default config.
func Startup(config *Config) {
	once.Do(func() {
		startup(config)
	})
}

func startup(config *Config) {
	lock.Lock()
	defer lock.Unlock()

	if isStarted || isShutdown {
		return
	}

	runtime.LockOSThread()
	defer runtime.UnlockOSThread()

	if MajorVersion < 8 || (MajorVersion == 8 && MinorVersion < 10) {
		panic("requires libvips version 8.10+")
	}

	cName := C.CString("vips")
	defer freeCString(cName)

	// Override default glib logging handler to intercept logging messages
	enableLogging()

	err := C.vips_init(cName)
	if err != 0 {
		panic(fmt.Sprintf("Failed to start vips code=%v", err))
	}

	if config != nil {
		C.vips_leak_set(toGboolean(config.ReportLeaks))
	}

	if config != nil && config.ConcurrencyLevel >= 0 {
		C.vips_concurrency_set(C.int(config.ConcurrencyLevel))
	} else {
		C.vips_concurrency_set(1)
	}

	if config != nil && config.MaxCacheFiles >= 0 {
		C.vips_cache_set_max_files(C.int(config.MaxCacheFiles))
	} else {
		C.vips_cache_set_max_files(0)
	}

	if config != nil && config.MaxCacheMem >= 0 {
		C.vips_cache_set_max_mem(C.size_t(config.MaxCacheMem))
	} else {
		C.vips_cache_set_max_mem(0)
	}

	if config != nil && config.MaxCacheSize >= 0 {
		C.vips_cache_set_max(C.int(config.MaxCacheSize))
	} else {
		C.vips_cache_set_max(0)
	}

	if config != nil && config.VectorEnabled {
		C.vips_vector_set_enabled(1)
	} else {
		C.vips_vector_set_enabled(0)
	}

	if config != nil && config.CacheTrace {
		C.vips_cache_set_trace(toGboolean(true))
	}

	log("vips", LogLevelInfo, fmt.Sprintf("vips %s started with concurrency=%d cache_max_files=%d cache_max_mem=%d cache_max=%d",
		Version,
		int(C.vips_concurrency_get()),
		int(C.vips_cache_get_max_files()),
		int(C.vips_cache_get_max_mem()),
		int(C.vips_cache_get_max())))

	isStarted = true
}

// Shutdown libvips
func Shutdown() {
	lock.Lock()
	defer lock.Unlock()

	if !isStarted || isShutdown {
		return
	}

	runtime.LockOSThread()
	defer runtime.UnlockOSThread()

	C.vips_shutdown()
	disableLogging()

	isShutdown = true
}

// MemoryStats is a data structure that houses various memory statistics from ReadVipsMemStats()
type MemoryStats struct {
	Mem     int64
	MemHigh int64
	Files   int64
	Allocs  int64
}

// ReadVipsMemStats returns various memory statistics such as allocated memory and open files.
func ReadVipsMemStats(stats *MemoryStats) {
	stats.Mem = int64(C.vips_tracked_get_mem())
	stats.MemHigh = int64(C.vips_tracked_get_mem_highwater())
	stats.Allocs = int64(C.vips_tracked_get_allocs())
	stats.Files = int64(C.vips_tracked_get_files())
}


func handleImageError(out *C.VipsImage) error {
	if out != nil {
		clearImage(out)
	}
	return handleVipsError()
}

func handleVipsError() error {
	s := C.GoString(C.vips_error_buffer())
	C.vips_error_clear()

	return fmt.Errorf("%v", s)
}

func freeCString(s *C.char) {
	C.free(unsafe.Pointer(s))
}

func gFreePointer(ref unsafe.Pointer) {
	C.g_free(C.gpointer(ref))
}

func boolToInt(b bool) int {
	if b {
		return 1
	}
	return 0
}

func boolToStr(v bool) string {
	if v {
		return "TRUE"
	}
	return "FALSE"
}

func toGboolean(b bool) C.gboolean {
	if b {
		return C.gboolean(1)
	}
	return C.gboolean(0)
}

func fromGboolean(b C.gboolean) bool {
	return b != 0
}

var cStringsCache sync.Map

func cachedCString(str string) *C.char {
	if cstr, ok := cStringsCache.Load(str); ok {
		return cstr.(*C.char)
	}
	cstr := C.CString(str)
	cStringsCache.Store(str, cstr)
	return cstr
}

// clearImage frees the VipsImage
func clearImage(img *C.VipsImage) {
	C.g_object_unref(C.gpointer(img))
}


// Param libvips options param
type Param struct {
	value interface{}
	isSet bool
}

// IsSet is param set
func (p *Param) IsSet() bool {
	return p.isSet
}

func (p *Param) set(v interface{}) {
	p.value = v
	p.isSet = true
}

// BoolParam bool param
type BoolParam struct {
	Param
}

// Set bool param
func (p *BoolParam) Set(v bool) {
	p.set(v)
}

// Get bool param
func (p *BoolParam) Get() bool {
	return p.value.(bool)
}

// IntParam int param
type IntParam struct {
	Param
}

// Set int param
func (p *IntParam) Set(v int) {
	p.set(v)
}

// Get int param
func (p *IntParam) Get() int {
	return p.value.(int)
}
