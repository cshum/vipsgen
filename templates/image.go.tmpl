// Code generated by github.com/cshum/vipsgen. DO NOT EDIT.

package vips

// #include "vips.h"
import "C"

import (
	"fmt"
	"strconv"
	"strings"
	"sync"
)

// Image contains a libvips image and manages its lifecycle.
type Image struct {
	// NOTE: We keep a reference to this so that the input buffer is
	// never garbage collected during processing. Some image loaders use random
	// access transcoding and therefore need the original buffer to be in memory.
	buf    []byte
	image  *C.VipsImage
	format ImageType
	lock   sync.Mutex

	pageHeight int // cached page height
}

// Param libvips options param
type Param struct {
	value interface{}
	isSet bool
}

// IsSet is param set
func (p *Param) IsSet() bool {
	return p.isSet
}

func (p *Param) set(v interface{}) {
	p.value = v
	p.isSet = true
}

// BoolParam bool param
type BoolParam struct {
	Param
}

// Set bool param
func (p *BoolParam) Set(v bool) {
	p.set(v)
}

// Get bool param
func (p *BoolParam) Get() bool {
	return p.value.(bool)
}

// IntParam int param
type IntParam struct {
	Param
}

// Set int param
func (p *IntParam) Set(v int) {
	p.set(v)
}

// Get int param
func (p *IntParam) Get() int {
	return p.value.(int)
}

// ImportParams are options for loading an image. Some are type-specific.
// For default loading, use NewImportParams() or specify nil
type ImportParams struct {
	AutoRotate  BoolParam
	FailOnError BoolParam
	Page        IntParam
	NumPages    IntParam
	Density     IntParam

	JpegShrinkFactor IntParam
	HeifThumbnail    BoolParam
	SvgUnlimited     BoolParam
}

// NewImportParams creates default ImportParams
func NewImportParams() *ImportParams {
	p := &ImportParams{}
	p.FailOnError.Set(true)
	return p
}

// OptionString convert import params to option_string
func (i *ImportParams) OptionString() string {
	var values []string
	if v := i.NumPages; v.IsSet() {
		values = append(values, "n="+strconv.Itoa(v.Get()))
	}
	if v := i.Page; v.IsSet() {
		values = append(values, "page="+strconv.Itoa(v.Get()))
	}
	if v := i.Density; v.IsSet() {
		values = append(values, "dpi="+strconv.Itoa(v.Get()))
	}
	if v := i.FailOnError; v.IsSet() {
		values = append(values, "fail="+boolToStr(v.Get()))
	}
	if v := i.JpegShrinkFactor; v.IsSet() {
		values = append(values, "shrink="+strconv.Itoa(v.Get()))
	}
	if v := i.AutoRotate; v.IsSet() {
		values = append(values, "autorotate="+boolToStr(v.Get()))
	}
	if v := i.SvgUnlimited; v.IsSet() {
		values = append(values, "unlimited="+boolToStr(v.Get()))
	}
	if v := i.HeifThumbnail; v.IsSet() {
		values = append(values, "thumbnail="+boolToStr(v.Get()))
	}
	return strings.Join(values, ",")
}

// LoadImageFromSource loads a Source and creates a new Image
func LoadImageFromSource(s *Source, params *ImportParams) (*Image, error) {
	if params == nil {
		params = NewImportParams()
	}

	vipsImage, format, err := vipsImageFromSource(s.src, params)
	if err != nil {
		return nil, err
	}

	ref := newImageRef(vipsImage, format, nil)
	log("vips", LogLevelDebug, fmt.Sprintf("created imageRef %p", ref))
	return ref, nil
}

// LoadThumbnailFromSource loads a Source and creates a new Image with thumbnail crop and resize
func LoadThumbnailFromSource(s *Source, width, height int, crop Interesting, size Size, params *ImportParams) (*Image, error) {
	if params == nil {
		params = NewImportParams()
	}

	vipsImage, format, err := vipsThumbnailFromSource(
		s.src, width, height, crop, size, params)
	if err != nil {
		return nil, err
	}

	ref := newImageRef(vipsImage, format, nil)
	log("vips", LogLevelDebug, fmt.Sprintf("created imageRef %p", ref))
	return ref, nil
}

// LoadImageFromBuffer loads an image buffer and creates a new Image
func LoadImageFromBuffer(buf []byte, params *ImportParams) (*Image, error) {
	StartupDefault()

	if params == nil {
		params = NewImportParams()
	}

	vipsImage, format, err := vipsImageFromBuffer(buf, params)
	if err != nil {
		return nil, err
	}

	ref := newImageRef(vipsImage, format, buf)

	log("vips", LogLevelDebug, fmt.Sprintf("created imageRef %p", ref))
	return ref, nil
}

// LoadImageFromMemory loads a raw RGB/RGBA image buffer and creates a new Image
func LoadImageFromMemory(buf []byte, width, height, bands int) (*Image, error) {
	StartupDefault()

	vipsImage, format, err := vipsImageFromMemory(buf, width, height, bands)
	if err != nil {
		return nil, err
	}

	ref := newImageRef(vipsImage, format, buf)

	log("vips", LogLevelDebug, fmt.Sprintf("created imageRef %p", ref))
	return ref, nil
}

func newImageRef(vipsImage *C.VipsImage, format ImageType, buf []byte) *Image {
	imageRef := &Image{
		image:  vipsImage,
		format: format,
		buf:    buf,
	}
	return imageRef
}

// setImage resets the image for this image and frees the previous one
func (r *Image) setImage(image *C.VipsImage) {
	r.lock.Lock()
	defer r.lock.Unlock()

	if r.image == image {
		return
	}

	if r.image != nil {
		clearImage(r.image)
	}

	r.image = image
	r.pageHeight = 0
}

// Close closes the image and frees the memory
func (r *Image) Close() {
	r.lock.Lock()
	if r.image != nil {
		clearImage(r.image)
		r.image = nil
		log("vips", LogLevelDebug, fmt.Sprintf("closing image %p", r))
	}
	r.buf = nil
	r.lock.Unlock()
}

// Format returns the initial format of the vips image when loaded.
func (r *Image) Format() ImageType {
	return r.format
}

// Width returns the width of this image.
func (r *Image) Width() int {
	return int(r.image.Xsize)
}

// Height returns the height of this image.
func (r *Image) Height() int {
	return int(r.image.Ysize)
}

// Bands returns the number of bands for this image.
func (r *Image) Bands() int {
	return int(r.image.Bands)
}

// HasAlpha returns if the image has an alpha layer.
func (r *Image) HasAlpha() bool {
	return vipsHasAlpha(r.image)
}

// Orientation returns the orientation number as it appears in the Exif, if present
func (r *Image) Orientation() int {
	return vipsGetMetaOrientation(r.image)
}

// Interpretation returns the current interpretation of the color space of the image.
func (r *Image) Interpretation() Interpretation {
	return Interpretation(int(r.image.Type))
}

// ColorSpace returns the interpretation of the current color space. Alias to Interpretation().
func (r *Image) ColorSpace() Interpretation {
	return r.Interpretation()
}

// Pages returns the number of pages in the Image
// For animated images this corresponds to the number of frames
func (r *Image) Pages() int {
    {{range .ImageTypes}}{{if eq .TypeName "jp2k"}}
    // libvips uses the same attribute (n_pages) to represent the number of pyramid layers in JP2K
    // as we interpret the attribute as frames and JP2K does not support animation we override this with 1
    if r.format == ImageTypeJp2k {
        return 1
    }
    {{end}}{{end}}
    return vipsGetImageNPages(r.image)
}

// PageHeight return the height of a single page
func (r *Image) PageHeight() int {
	if r.pageHeight == 0 {
		r.pageHeight = vipsGetPageHeight(r.image)
	}
	return r.pageHeight
}

// SetPageHeight set the height of a page
// For animated images this is used when "unrolling" back to frames
func (r *Image) SetPageHeight(height int) error {
	out, err := vipsCopyImage(r.image)
	if err != nil {
		return err
	}

	vipsSetPageHeight(out, height)

	r.setImage(out)
	return nil
}

// SetPageDelay set the page delay array for animation
func (r *Image) SetPageDelay(delay []int) error {
	var data []C.int
	for _, d := range delay {
		data = append(data, C.int(d))
	}
	return vipsImageSetDelay(r.image, data)
}

// Exif extracts Exif key value data
func (r *Image) Exif() map[string]any {
	return vipsImageGetExif(r.image)
}



{{range .Operations}}{{if and .HasImageInput (not (hasArrayImageInput .Arguments))}}
// {{.GoName | imageMethodName}} {{.Description}}
// {{generateDocUrl .Name .Category}}
func (r *Image) {{.GoName | imageMethodName}}({{$inputParams := filterInputParams .Arguments}}{{range $i, $arg := $inputParams}}{{if $i}}, {{end}}{{$arg.GoName}} {{$arg.GoType}}{{end}}) ({{if .HasImageOutput}}error{{else if .Outputs}}{{range $i, $arg := .Outputs}}{{if $i}}, {{end}}{{$arg.GoType}}{{end}}, error{{else}}error{{end}}) {
    {{if .HasImageOutput}}
    out, err := {{.GoName}}(r.image{{range $arg := .Arguments}}{{if and (not $arg.IsOutput) (ne $arg.Name "in") (ne $arg.Name "out")}}, {{$arg.GoName}}{{end}}{{end}})
    if err != nil {
        return err
    }
    r.setImage(out)
    return nil
    {{else if .Outputs}}
    {{range $i, $arg := .Outputs}}{{if $i}}, {{end}}{{$arg.GoName}}{{end}}, err := {{.GoName}}(r.image{{range $arg := .Arguments}}{{if and (not $arg.IsOutput) (ne $arg.Name "in") (ne $arg.Name "out")}}, {{$arg.GoName}}{{end}}{{end}})
    if err != nil {
        return {{range $i, $arg := .Outputs}}{{if $i}}, {{end}}{{if eq (index (split $arg.GoType "[]") 0) ""}}nil{{else if eq $arg.GoType "bool"}}false{{else if eq $arg.GoType "string"}}""{{else if eq $arg.GoType "*C.VipsImage"}}nil{{else}}0{{end}}{{end}}, err
    }
    return {{range $i, $arg := .Outputs}}{{if $i}}, {{end}}{{$arg.GoName}}{{end}}, nil
    {{else}}
    err := {{.GoName}}(r.image{{range $arg := .Arguments}}{{if and (not $arg.IsOutput) (ne $arg.Name "in") (ne $arg.Name "out")}}, {{$arg.GoName}}{{end}}{{end}})
    if err != nil {
        return err
    }
    return nil
    {{end}}
}
{{end}}{{end}}
