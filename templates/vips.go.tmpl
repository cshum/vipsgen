// Code generated by github.com/cshum/vipsgen. DO NOT EDIT.
package vips

// #include "vips.h"
import "C"
import (
	"fmt"
	"runtime"
	"sync"
	"unsafe"
)

func handleImageError(out *C.VipsImage) error {
	if out != nil {
		clearImage(out)
	}
	return handleVipsError()
}

func handleVipsError() error {
	s := C.GoString(C.vips_error_buffer())
	C.vips_error_clear()

	return fmt.Errorf("%v", s)
}

func freeCString(s *C.char) {
	C.free(unsafe.Pointer(s))
}

func gFreePointer(ref unsafe.Pointer) {
	C.g_free(C.gpointer(ref))
}

func boolToInt(b bool) int {
	if b {
		return 1
	}
	return 0
}

func boolToStr(v bool) string {
	if v {
		return "TRUE"
	}
	return "FALSE"
}

func toGboolean(b bool) C.gboolean {
	if b {
		return C.gboolean(1)
	}
	return C.gboolean(0)
}

func fromGboolean(b C.gboolean) bool {
	return b != 0
}

var cStringsCache sync.Map

func cachedCString(str string) *C.char {
	if cstr, ok := cStringsCache.Load(str); ok {
		return cstr.(*C.char)
	}
	cstr := C.CString(str)
	cStringsCache.Store(str, cstr)
	return cstr
}

// clearImage frees the VipsImage
func clearImage(img *C.VipsImage) {
	C.g_object_unref(C.gpointer(img))
}


// https://www.libvips.org/API/current/VipsImage.html#vips-image-new-from-source
func vipsImageFromSource(
	src *C.VipsSourceCustom, params *ImportParams,
) (*C.VipsImage, ImageType, error) {
	var out *C.VipsImage
	var code C.int
	var optionString string

	if params != nil {
		optionString = params.OptionString()
	}
	if optionString == "" {
		code = C.image_new_from_source(src, &out)
	} else {
		cOptionString := C.CString(optionString)
		defer freeCString(cOptionString)

		code = C.image_new_from_source_with_option(src, &out, cOptionString)
	}
	if code != 0 {
		return nil, ImageTypeUnknown, handleImageError(out)
	}

	imageType := vipsDetermineImageTypeFromMetaLoader(out)
	return out, imageType, nil
}

// https://www.libvips.org/API/current/VipsImage.html#vips-image-new-from-buffer
func vipsImageFromBuffer(buf []byte, params *ImportParams) (*C.VipsImage, ImageType, error) {
	src := buf
	// Reference src here so it's not garbage collected during image initialization.
	defer runtime.KeepAlive(src)

	var out *C.VipsImage
	var code C.int
	var optionString string
	if params != nil {
		optionString = params.OptionString()
	}
	if optionString == "" {
		code = C.image_new_from_buffer(unsafe.Pointer(&src[0]), C.size_t(len(src)), &out)
	} else {
		cOptionString := C.CString(optionString)
		defer freeCString(cOptionString)

		code = C.image_new_from_buffer_with_option(unsafe.Pointer(&src[0]), C.size_t(len(src)), &out, cOptionString)
	}
	if code != 0 {
		return nil, ImageTypeUnknown, handleImageError(out)
	}

	imageType := vipsDetermineImageTypeFromMetaLoader(out)
	return out, imageType, nil
}

// https://www.libvips.org/API/current/VipsImage.html#vips-image-new-from-buffer
func vipsImageFromMemory(buf []byte, width, height, bands int) (*C.VipsImage, ImageType, error) {
	src := buf
	// Reference src here so it's not garbage collected during image initialization.
	defer runtime.KeepAlive(src)

	var out *C.VipsImage
	var code C.int
	code = C.image_new_from_memory(unsafe.Pointer(&src[0]), C.size_t(len(src)), C.int(width), C.int(height), C.int(bands), &out)
	if code != 0 {
		return nil, ImageTypeUnknown, handleImageError(out)
	}

	return out, ImageTypeUnknown, nil
}

// https://www.libvips.org/API/current/libvips-resample.html#vips-thumbnail-source
func vipsThumbnailFromSource(
	src *C.VipsSourceCustom, width, height int, crop Interesting, size Size, params *ImportParams) (*C.VipsImage, ImageType, error) {
	var out *C.VipsImage
	var code C.int
	var optionString string

	if params != nil {
		optionString = params.OptionString()
	}
	if optionString == "" {
		code = C.thumbnail_source(src, &out, C.int(width), C.int(height), C.int(crop), C.int(size))
	} else {
		cOptionString := C.CString(optionString)
		defer freeCString(cOptionString)

		code = C.thumbnail_source_with_option(src, &out, C.int(width), C.int(height), C.int(crop), C.int(size), cOptionString)
	}
	if code != 0 {
		return nil, ImageTypeUnknown, handleImageError(out)
	}

	imageType := vipsDetermineImageTypeFromMetaLoader(out)
	return out, imageType, nil
}

func vipsHasAlpha(in *C.VipsImage) bool {
	return int(C.has_alpha_channel(in)) > 0
}

// https://libvips.github.io/libvips/API/current/libvips-conversion.html#vips-copy
func vipsCopyImage(in *C.VipsImage) (*C.VipsImage, error) {
	var out *C.VipsImage

	if err := C.copy_image(in, &out); int(err) != 0 {
		return nil, handleImageError(out)
	}

	return out, nil
}

// https://libvips.github.io/libvips/API/current/libvips-conversion.html#vips-embed
func vipsEmbed(in *C.VipsImage, left, top, width, height int, extend Extend) (*C.VipsImage, error) {
	var out *C.VipsImage

	if err := C.embed_image(in, &out, C.int(left), C.int(top), C.int(width), C.int(height), C.int(extend)); err != 0 {
		return nil, handleImageError(out)
	}

	return out, nil
}

// https://libvips.github.io/libvips/API/current/libvips-conversion.html#vips-embed
func vipsEmbedBackground(in *C.VipsImage, left, top, width, height int, backgroundColor *ColorRGBA) (*C.VipsImage, error) {
	var out *C.VipsImage

	if err := C.embed_image_background(in, &out, C.int(left), C.int(top), C.int(width),
		C.int(height), C.double(backgroundColor.R),
		C.double(backgroundColor.G), C.double(backgroundColor.B), C.double(backgroundColor.A)); err != 0 {
		return nil, handleImageError(out)
	}

	return out, nil
}

func vipsEmbedMultiPage(in *C.VipsImage, left, top, width, height int, extend Extend) (*C.VipsImage, error) {
	var out *C.VipsImage

	if err := C.embed_multi_page_image(in, &out, C.int(left), C.int(top), C.int(width), C.int(height), C.int(extend)); err != 0 {
		return nil, handleImageError(out)
	}

	return out, nil
}

func vipsEmbedMultiPageBackground(in *C.VipsImage, left, top, width, height int, backgroundColor *ColorRGBA) (*C.VipsImage, error) {
	var out *C.VipsImage

	if err := C.embed_multi_page_image_background(in, &out, C.int(left), C.int(top), C.int(width),
		C.int(height), C.double(backgroundColor.R),
		C.double(backgroundColor.G), C.double(backgroundColor.B), C.double(backgroundColor.A)); err != 0 {
		return nil, handleImageError(out)
	}

	return out, nil
}

func vipsExtractAreaMultiPage(in *C.VipsImage, left, top, width, height int) (*C.VipsImage, error) {
	var out *C.VipsImage

	if err := C.extract_area_multi_page(in, &out, C.int(left), C.int(top), C.int(width), C.int(height)); err != 0 {
		return nil, handleImageError(out)
	}

	return out, nil
}

// https://libvips.github.io/libvips/API/current/libvips-conversion.html#vips-rot
func vipsRotate(in *C.VipsImage, angle Angle) (*C.VipsImage, error) {
	var out *C.VipsImage

	if err := C.rotate_image(in, &out, C.VipsAngle(angle)); err != 0 {
		return nil, handleImageError(out)
	}

	return out, nil
}

// https://libvips.github.io/libvips/API/current/libvips-conversion.html#vips-rot
func vipsRotateMultiPage(in *C.VipsImage, angle Angle) (*C.VipsImage, error) {
	var out *C.VipsImage

	if err := C.rotate_image_multi_page(in, &out, C.VipsAngle(angle)); err != 0 {
		return nil, handleImageError(out)
	}

	return out, nil
}

func vipsLabel(
	in *C.VipsImage,
	text, font string,
	x, y, size int, align Align,
	color *Color, opacity float64,
) (*C.VipsImage, error) {
	var out *C.VipsImage
	cText := C.CString(text)
	defer freeCString(cText)
	cFont := C.CString(font)
	defer freeCString(cFont)

	err := C.label_image(in, &out, cText, cFont,
		C.int(x), C.int(y), C.int(size), C.VipsAlign(align),
		C.double(color.R), C.double(color.G), C.double(color.B), C.float(float32(opacity)))
	if int(err) != 0 {
		return nil, handleImageError(out)
	}

	return out, nil
}

func vipsAddAlpha(in *C.VipsImage) (*C.VipsImage, error) {
	var out *C.VipsImage

	if err := C.add_alpha(in, &out); err != 0 {
		return nil, handleImageError(out)
	}

	return out, nil
}

// https://libvips.github.io/libvips/API/current/libvips-conversion.html#vips-composite2
func vipsComposite2(base *C.VipsImage, overlay *C.VipsImage, mode BlendMode, x, y int) (*C.VipsImage, error) {
	var out *C.VipsImage

	if err := C.composite2_image(base, overlay, &out, C.int(mode), C.gint(x), C.gint(y)); err != 0 {
		return nil, handleImageError(out)
	}

	return out, nil
}

//  https://libvips.github.io/libvips/API/current/libvips-arithmetic.html#vips-linear
func vipsLinear(in *C.VipsImage, a, b []float64, n int) (*C.VipsImage, error) {
	var out *C.VipsImage

	if err := C.linear(in, &out, (*C.double)(&a[0]), (*C.double)(&b[0]), C.int(n)); err != 0 {
		return nil, handleImageError(out)
	}

	return out, nil
}

// https://libvips.github.io/libvips/API/current/libvips-arithmetic.html#vips-getpoint
func vipsGetPoint(in *C.VipsImage, n int, x int, y int) ([]float64, error) {
	var out *C.double
	defer gFreePointer(unsafe.Pointer(out))

	if err := C.getpoint(in, &out, C.int(n), C.int(x), C.int(y)); err != 0 {
		return nil, handleVipsError()
	}

	// maximum n is 4
	return (*[4]float64)(unsafe.Pointer(out))[:n:n], nil
}

// https://libvips.github.io/libvips/API/current/libvips-colour.html#vips-colourspace
func vipsToColorSpace(in *C.VipsImage, interpretation Interpretation) (*C.VipsImage, error) {
	var out *C.VipsImage

	inter := C.VipsInterpretation(interpretation)

	if err := C.to_colorspace(in, &out, inter); err != 0 {
		return nil, handleImageError(out)
	}

	return out, nil
}

// https://libvips.github.io/libvips/API/current/libvips-convolution.html#vips-gaussblur
func vipsGaussianBlur(in *C.VipsImage, sigma float64) (*C.VipsImage, error) {
	var out *C.VipsImage

	if err := C.gaussian_blur_image(in, &out, C.double(sigma)); err != 0 {
		return nil, handleImageError(out)
	}

	return out, nil
}


func vipsRemoveICCProfile(in *C.VipsImage) bool {
	return fromGboolean(C.remove_icc_profile(in))
}

func vipsRemoveExif(in *C.VipsImage) (*C.VipsImage, error) {
	var out *C.VipsImage

	if err := C.remove_exif(in, &out); err != 0 {
		return nil, handleImageError(out)
	}

	return out, nil
}

func vipsGetMetaOrientation(in *C.VipsImage) int {
	return int(C.get_meta_orientation(in))
}

func vipsGetImageNPages(in *C.VipsImage) int {
	return int(C.get_image_n_pages(in))
}

func vipsGetPageHeight(in *C.VipsImage) int {
	return int(C.get_page_height(in))
}

func vipsSetPageHeight(in *C.VipsImage, height int) {
	C.set_page_height(in, C.int(height))
}

func vipsImageGetMetaLoader(in *C.VipsImage) (string, bool) {
	var out *C.char
	defer gFreePointer(unsafe.Pointer(out))
	code := int(C.get_meta_loader(in, &out))
	return C.GoString(out), code == 0
}

func vipsImageSetDelay(in *C.VipsImage, data []C.int) error {
	if n := len(data); n > 0 {
		C.set_image_delay(in, &data[0], C.int(n))
	}
	return nil
}

func vipsGetMetaString(image *C.VipsImage, name string) string {
	return C.GoString(C.get_meta_string(image, cachedCString(name)))
}


{{range .Operations}}
// {{.GoName}} {{.Description}}
// https://libvips.github.io/libvips/API/current/libvips-{{.Category}}.html#vips-{{.Name}}
func {{.GoName}}({{$first := true}}{{range $arg := .Arguments}}{{if not $arg.IsOutput}}{{if $first}}{{$first = false}}{{else}}, {{end}}{{$arg.GoName}} {{$arg.GoType}}{{end}}{{end}}) ({{if .HasImageOutput}}*C.VipsImage, error{{else}}{{if .Outputs}}{{range $i, $arg := .Outputs}}{{if $i}}, {{end}}{{$arg.GoType}}{{end}}, error{{else}}error{{end}}{{end}}) {
    {{if .HasImageOutput}}
    var out *C.VipsImage
    {{else if .Outputs}}
    {{range $arg := .Outputs}}
    var {{$arg.GoName}}Out {{$arg.GoType}}
    {{end}}
    {{end}}

    {{range .Arguments}}{{if and (not .IsOutput) (eq .GoType "string")}}
    c{{.GoName}} := C.CString({{.GoName}})
    defer freeCString(c{{.GoName}}){{end}}{{end}}

    {{if .HasImageOutput}}
    if err := C.{{.Name}}_wrapper({{$first := true}}{{range $arg := .Arguments}}{{if not $arg.IsOutput}}{{if $first}}{{$first = false}}{{else}}, {{end}}
        {{- if eq $arg.GoType "string"}}c{{$arg.GoName}}
        {{- else if eq $arg.GoType "bool"}}C.int(boolToInt({{$arg.GoName}}))
        {{- else if eq $arg.GoType "*C.VipsImage"}}{{$arg.GoName}}
        {{- else if $arg.IsEnum}}C.{{$arg.Type}}({{$arg.GoName}})
        {{- else}}C.{{$arg.CType}}({{$arg.GoName}}){{- end}}{{end}}{{end}},
        &out); err != 0 {
        return nil, handleImageError(out)
    }

    return out, nil
    {{else if .Outputs}}
    if err := C.{{.Name}}_wrapper({{$first := true}}{{range $arg := .Arguments}}{{if not $arg.IsOutput}}{{if $first}}{{$first = false}}{{else}}, {{end}}
        {{- if eq $arg.GoType "string"}}c{{$arg.GoName}}
        {{- else if eq $arg.GoType "bool"}}C.int(boolToInt({{$arg.GoName}}))
        {{- else if eq $arg.GoType "*C.VipsImage"}}{{$arg.GoName}}
        {{- else if $arg.IsEnum}}C.{{$arg.Type}}({{$arg.GoName}})
        {{- else}}C.{{$arg.CType}}({{$arg.GoName}}){{- end}}{{end}}{{end}}{{range $arg := .Outputs}},
        &{{$arg.GoName}}Out{{end}}); err != 0 {
        return {{range $i, $arg := .Outputs}}{{if $i}}, {{end}}{{if eq (index (split $arg.GoType "[]") 0) ""}}nil{{else if eq $arg.GoType "bool"}}false{{else if eq $arg.GoType "string"}}""{{else}}0{{end}}{{end}}, handleVipsError()
    }

    return {{range $i, $arg := .Outputs}}{{if $i}}, {{end}}{{$arg.GoName}}Out{{end}}, nil
    {{else}}
    if err := C.{{.Name}}_wrapper({{$first := true}}{{range $arg := .Arguments}}{{if not $arg.IsOutput}}{{if $first}}{{$first = false}}{{else}}, {{end}}
        {{- if eq $arg.GoType "string"}}c{{$arg.GoName}}
        {{- else if eq $arg.GoType "bool"}}C.int(boolToInt({{$arg.GoName}}))
        {{- else if eq $arg.GoType "*C.VipsImage"}}{{$arg.GoName}}
        {{- else if $arg.IsEnum}}C.{{$arg.Type}}({{$arg.GoName}})
        {{- else}}C.{{$arg.CType}}({{$arg.GoName}}){{- end}}{{end}}{{end}}); err != 0 {
        return handleVipsError()
    }

    return nil
    {{end}}
}
{{end}}
