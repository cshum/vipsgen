// Code generated by github.com/cshum/vipsgen. DO NOT EDIT.
package vips

// #include "vips.h"
import "C"
import (
	"runtime"
	"unsafe"
)

{{range .Operations}}
{{generateGoFunctionBody . false}}
{{if gt (len .OptionalInputs) 0}}
{{generateGoFunctionBody . true}}
{{end}}{{end}}

// vipsImageFromSource vips_image_new_from_source
func vipsImageFromSource(src *C.VipsSourceCustom, params *LoadOptions) (*C.VipsImage, error) {
	var out *C.VipsImage
	var code C.int
	var optionString string

	if params != nil {
		optionString = params.OptionString()
	}
	if optionString == "" {
		code = C.vipsgen_image_new_from_source(src, &out)
	} else {
		cOptionString := C.CString(optionString)
		defer freeCString(cOptionString)

		code = C.vipsgen_image_new_from_source_with_option(src, &out, cOptionString)
	}
	if code != 0 {
		return nil, handleImageError(out)
	}
	return out, nil
}

// vipsImageFromBuffer vips_image_new_from_buffer
func vipsImageFromBuffer(buf []byte, params *LoadOptions) (*C.VipsImage, error) {
	src := buf
	// Reference src here so it's not garbage collected during image initialization.
	defer runtime.KeepAlive(src)

	var out *C.VipsImage
	var code C.int
	var optionString string
	if params != nil {
		optionString = params.OptionString()
	}
	if optionString == "" {
		code = C.vipsgen_image_new_from_buffer(unsafe.Pointer(&src[0]), C.size_t(len(src)), &out)
	} else {
		cOptionString := C.CString(optionString)
		defer freeCString(cOptionString)

		code = C.vipsgen_image_new_from_buffer_with_option(unsafe.Pointer(&src[0]), C.size_t(len(src)), &out, cOptionString)
	}
	if code != 0 {
		return nil, handleImageError(out)
	}
	return out, nil
}

// vipsImageFromFile vips_image_new_from_file
func vipsImageFromFile(path string, params *LoadOptions) (*C.VipsImage, error) {
	// Append options to the filename if needed
	filenameOption := path
	if params != nil && params.OptionString() != "" {
		filenameOption += "[" + params.OptionString() + "]"
	}

	cPath := C.CString(filenameOption)
	defer freeCString(cPath)

	var out *C.VipsImage
	code := C.vipsgen_image_new_from_file(cPath, &out)

	if code != 0 {
		return nil, handleImageError(out)
	}
	return out, nil
}

// vipsImageFromMemory vips_image_new_memory
func vipsImageFromMemory(buf []byte, width, height, bands int) (*C.VipsImage, error) {
	src := buf
	// Reference src here so it's not garbage collected during image initialization.
	defer runtime.KeepAlive(src)

	var out *C.VipsImage
	var code C.int
	code = C.vipsgen_image_new_from_memory(unsafe.Pointer(&src[0]), C.size_t(len(src)), C.int(width), C.int(height), C.int(bands), &out)
	if code != 0 {
		return nil, handleImageError(out)
	}
	return out, nil
}

func vipsHasAlpha(in *C.VipsImage) bool {
	return int(C.has_alpha_channel(in)) > 0
}

func vipsEmbedMultiPage(in *C.VipsImage, left, top, width, height int, extend Extend) (*C.VipsImage, error) {
	var out *C.VipsImage
	if err := C.embed_multi_page(in, &out, C.int(left), C.int(top), C.int(width), C.int(height), C.int(extend)); err != 0 {
		return nil, handleImageError(out)
	}
	return out, nil
}

func vipsEmbedMultiPageBackground(in *C.VipsImage, left, top, width, height,
	backgroundColorR, backgroundColorG, backgroundColorB, backgroundColorA int) (*C.VipsImage, error) {
	var out *C.VipsImage
	if err := C.embed_multi_page_background(in, &out, C.int(left), C.int(top), C.int(width),
		C.int(height), C.double(backgroundColorR),
		C.double(backgroundColorG), C.double(backgroundColorB), C.double(backgroundColorA)); err != 0 {
		return nil, handleImageError(out)
	}
	return out, nil
}

func vipsExtractAreaMultiPage(in *C.VipsImage, left, top, width, height int) (*C.VipsImage, error) {
	var out *C.VipsImage
	if err := C.extract_area_multi_page(in, &out, C.int(left), C.int(top), C.int(width), C.int(height)); err != 0 {
		return nil, handleImageError(out)
	}
	return out, nil
}

func vipsRotateMultiPage(in *C.VipsImage, angle Angle) (*C.VipsImage, error) {
	var out *C.VipsImage
	if err := C.rotate_image_multi_page(in, &out, C.VipsAngle(angle)); err != 0 {
		return nil, handleImageError(out)
	}
	return out, nil
}

func vipsLabel(
	in *C.VipsImage,
	text, font string,
	x, y, size int, align Align,
	colorR, colorG, colorB int, opacity float64,
) (*C.VipsImage, error) {
	var out *C.VipsImage
	cText := C.CString(text)
	defer freeCString(cText)
	cFont := C.CString(font)
	defer freeCString(cFont)

	err := C.label_image(in, &out, cText, cFont,
		C.int(x), C.int(y), C.int(size), C.VipsAlign(align),
		C.double(colorR), C.double(colorG), C.double(colorB), C.float(float32(opacity)))
	if int(err) != 0 {
		return nil, handleImageError(out)
	}

	return out, nil
}

func vipsRemoveICCProfile(in *C.VipsImage) bool {
	return fromGboolean(C.remove_icc_profile(in))
}

func vipsRemoveExif(in *C.VipsImage) (*C.VipsImage, error) {
	var out *C.VipsImage
	if err := C.remove_exif(in, &out); err != 0 {
		return nil, handleImageError(out)
	}
	return out, nil
}

func vipsGetMetaOrientation(in *C.VipsImage) int {
	return int(C.get_meta_orientation(in))
}

func vipsGetImageNPages(in *C.VipsImage) int {
	return int(C.get_image_n_pages(in))
}

func vipsGetPageHeight(in *C.VipsImage) int {
	return int(C.get_page_height(in))
}

func vipsSetPageHeight(in *C.VipsImage, height int) {
	C.set_page_height(in, C.int(height))
}

func vipsImageGetMetaLoader(in *C.VipsImage) (string, bool) {
	var out *C.char
	defer gFreePointer(unsafe.Pointer(out))
	code := int(C.get_meta_loader(in, &out))
	return C.GoString(out), code == 0
}

func vipsImageSetDelay(in *C.VipsImage, delay []int) error {
	cdelay, cn, err := convertToIntArray(delay)
	if err != nil {
		return err
	}
	if cdelay != nil {
		defer freeIntArray(cdelay)
		C.set_image_delay(in, cdelay, cn)
	}
	return nil
}

func vipsGetMetaString(image *C.VipsImage, name string) string {
	return C.GoString(C.get_meta_string(image, cachedCString(name)))
}

