// Code generated by github.com/cshum/vipsgen. DO NOT EDIT.

package vips

// #include "vips.h"
import "C"

import (
	"fmt"
	"strconv"
	"strings"
	"sync"
)

// Image contains a libvips image and manages its lifecycle.
type Image struct {
	// NOTE: We keep a reference to this so that the input buffer is
	// never garbage collected during processing. Some image loaders use random
	// access transcoding and therefore need the original buffer to be in memory.
	buf    []byte
	image  *C.VipsImage
	format ImageType
	lock   sync.Mutex

	pageHeight int // cached page height
}

{{range .Operations}}{{if and (not .HasThisImageInput) .HasImageOutput}}
{{generateOptionalInputsStruct .}}
// New{{.GoName}} {{.Description}}
func New{{.GoName}}({{generateMethodParams .}}) (*Image, error) {
	{{generateCreatorMethodBody .}}
}
{{end}}{{end}}

{{range .Operations}}{{if .HasThisImageInput}}
{{generateOptionalInputsStruct .}}
// {{.GoName}} {{.Description}}
func (r *Image) {{.GoName}}({{generateImageMethodParams .}}) ({{generateImageMethodReturnTypes .}}) {
	{{generateImageMethodBody .}}
}
{{end}}{{end}}

{{range .Operations}}{{if and (not .HasThisImageInput) (not .HasImageOutput)}}
// {{.GoName}} {{.Description}}
func {{.GoName}}({{generateMethodParams .}}) ({{generateUtilityFunctionReturnTypes .}}) {
	Startup(nil)
	return vipsgen{{.GoName}}({{generateUtilFunctionCallArgs .}})
}
{{end}}{{end}}

// LoadOptions are options for loading an image. Some are type-specific.
type LoadOptions struct {
	// N Number of pages to load, -1 for all
	N int
	// Page First page to load
	Page int
	// Dpi Resolution in DPI
	Dpi int
	// Autorotate Rotate image using exif orientation
	Autorotate bool
	// FailOnError Fail on first error
	FailOnError bool
	// Shrink Shrink factor for jpeg load
	Shrink int
	// Thumbnail Load the thumbnail instead of main image (for HEIF)
	Thumbnail bool
	// Unlimited Allow without size restrictions
	Unlimited bool
	// Memory Force open via memory
	Memory bool
	// Access Required access pattern for this file
	Access Access
}

// DefaultLoadOptions creates default LoadOptions
func DefaultLoadOptions() *LoadOptions {
	return &LoadOptions{
		FailOnError: true,
	}
}

// OptionString convert import params to option_string
func (i *LoadOptions) OptionString() string {
	var values []string
	if v := i.N; v != 0 {
		values = append(values, "n="+strconv.Itoa(v))
	}
	if v := i.Page; v != 0 {
		values = append(values, "page="+strconv.Itoa(v))
	}
	if v := i.Dpi; v != 0 {
		values = append(values, "dpi="+strconv.Itoa(v))
	}
	if v := i.FailOnError; v {
		values = append(values, "fail="+boolToStr(v))
	}
	if v := i.Shrink; v != 0 {
		values = append(values, "shrink="+strconv.Itoa(v))
	}
	if v := i.Autorotate; v {
		values = append(values, "autorotate="+boolToStr(v))
	}
	if v := i.Unlimited; v {
		values = append(values, "unlimited="+boolToStr(v))
	}
	if v := i.Thumbnail; v {
		values = append(values, "thumbnail="+boolToStr(v))
	}
	if v := i.Memory; v {
		values = append(values, "memory="+boolToStr(v))
	}
	if access := i.Access; access != 0 {
		switch access {
		case AccessSequential:
			values = append(values, "access=sequential")
		case AccessRandom:
			values = append(values, "access=random")
		case AccessSequentialUnbuffered:
			values = append(values, "access=sequential-unbuffered")
		}
	}
	return strings.Join(values, ",")
}

// NewImageFromSource vips_image_new_from_source loads a Source and creates a new Image
func NewImageFromSource(s *Source, options *LoadOptions) (*Image, error) {
	Startup(nil)
	if options == nil {
		options = DefaultLoadOptions()
	}
	vipsImage, err := vipsImageFromSource(s.src, options)
	if err != nil {
		return nil, err
	}
	return newImageRef(vipsImage, vipsDetermineImageType(vipsImage), nil), nil
}

// NewImageFromBuffer vips_image_new_from_buffer loads an image buffer and creates a new Image
func NewImageFromBuffer(buf []byte, options *LoadOptions) (*Image, error) {
	Startup(nil)
	if options == nil {
		options = DefaultLoadOptions()
	}
	vipsImage, err := vipsImageFromBuffer(buf, options)
	if err != nil {
		return nil, err
	}
	return newImageRef(vipsImage, vipsDetermineImageType(vipsImage), buf), nil
}

// NewImageFromFile vips_image_new_from_file loads an image from file and creates a new Image
func NewImageFromFile(file string, options *LoadOptions) (*Image, error) {
	Startup(nil)
	if options == nil {
		options = DefaultLoadOptions()
	}
	vipsImage, err := vipsImageFromFile(file, options)
	if err != nil {
		return nil, err
	}
	return newImageRef(vipsImage, vipsDetermineImageType(vipsImage), nil), nil
}

// NewImageFromMemory vips_image_new_from_memory loads a raw RGB/RGBA image buffer and creates a new Image
func NewImageFromMemory(buf []byte, width, height, bands int) (*Image, error) {
	Startup(nil)
	vipsImage, err := vipsImageFromMemory(buf, width, height, bands)
	if err != nil {
		return nil, err
	}
	return newImageRef(vipsImage, ImageTypeUnknown, buf), nil
}


func newImageRef(vipsImage *C.VipsImage, format ImageType, buf []byte) *Image {
	imageRef := &Image{
		image:  vipsImage,
		format: format,
		buf:    buf,
	}
	log("vipsgen", LogLevelDebug, fmt.Sprintf("created imageRef %p", imageRef))
	return imageRef
}

// setImage resets the image for this image and frees the previous one
func (r *Image) setImage(image *C.VipsImage) {
	r.lock.Lock()
	defer r.lock.Unlock()
	if r.image == image {
		return
	}
	if r.image != nil {
		clearImage(r.image)
	}
	r.image = image
	r.pageHeight = 0
}

// Close closes the image and frees the memory
func (r *Image) Close() {
	r.lock.Lock()
	if r.image != nil {
		clearImage(r.image)
		r.image = nil
		log("vipsgen", LogLevelDebug, fmt.Sprintf("closing image %p", r))
	}
	r.buf = nil
	r.lock.Unlock()
}

// Format returns the initial format of the vips image when loaded.
func (r *Image) Format() ImageType {
	return r.format
}

// Width returns the width of this image.
func (r *Image) Width() int {
	return int(r.image.Xsize)
}

// Height returns the height of this image.
func (r *Image) Height() int {
	return int(r.image.Ysize)
}

// Bands returns the number of bands for this image.
func (r *Image) Bands() int {
	return int(r.image.Bands)
}

// ResX returns the X resolution
func (r *Image) ResX() float64 {
	return float64(r.image.Xres)
}

// ResY returns the Y resolution
func (r *Image) ResY() float64 {
	return float64(r.image.Yres)
}

// OffsetX returns the X offset
func (r *Image) OffsetX() int {
	return int(r.image.Xoffset)
}

// OffsetY returns the Y offset
func (r *Image) OffsetY() int {
	return int(r.image.Yoffset)
}

// BandFormat returns the current band format
func (r *Image) BandFormat() BandFormat {
	return BandFormat(int(r.image.BandFmt))
}

// Coding returns the image coding
func (r *Image) Coding() Coding {
	return Coding(int(r.image.Coding))
}

// Interpretation returns the current interpretation of the color space of the image.
func (r *Image) Interpretation() Interpretation {
	return Interpretation(int(r.image.Type))
}

// IsColorSpaceSupported returns a boolean whether the image's color space is supported by libvips.
func (r *Image) IsColorSpaceSupported() bool {
	return vipsIsColorSpaceSupported(r.image)
}

// HasAlpha returns if the image has an alpha layer.
func (r *Image) HasAlpha() bool {
	return vipsHasAlpha(r.image)
}

// HasICCProfile checks whether the image has an ICC profile embedded.
func (r *Image) HasICCProfile() bool {
	return vipsHasICCProfile(r.image)
}

// HasIPTC returns a boolean whether the image in question has IPTC data associated with it.
func (r *Image) HasIPTC() bool {
	return vipsHasIPTC(r.image)
}

// Orientation returns the orientation number as it appears in the Exif, if present
func (r *Image) Orientation() int {
	return vipsGetMetaOrientation(r.image)
}

// GetFields vips_image_get_fields returns a list of all metadata field names in the image
func (r *Image) GetFields() []string {
	return vipsImageGetFields(r.image)
}

// GetBlob vips_image_get_blob retrieves binary metadata from the image by field name
func (r *Image) GetBlob(name string) ([]byte, error) {
	return vipsImageGetBlob(r.image, name)
}

// SetDouble vips_image_set_double sets a double-precision floating point metadata value
func (r *Image) SetDouble(name string, f float64) {
	vipsImageSetDouble(r.image, name, f)
}

// GetDouble vips_image_get_double retrieves a double-precision floating point metadata value
func (r *Image) GetDouble(name string) (float64, error) {
	return vipsImageGetDouble(r.image, name)
}

// SetInt vips_image_set_int sets an integer metadata value
func (r *Image) SetInt(name string, i int) {
	vipsImageSetInt(r.image, name, i)
}

// GetInt vips_image_get_int retrieves an integer metadata value
func (r *Image) GetInt(name string) (int, error) {
	return vipsImageGetInt(r.image, name)
}

// SetString vips_image_set_string sets a string metadata value
func (r *Image) SetString(name string, str string) {
	vipsImageSetString(r.image, name, str)
}

// GetString vips_image_get_string retrieves a string metadata value
func (r *Image) GetString(name string) (string, error) {
	return vipsImageGetString(r.image, name)
}

// GetAsString vips_image_get_as_string retrieves any metadata value converted to string format
func (r *Image) GetAsString(name string) (string, error) {
	return vipsImageGetAsString(r.image, name)
}

// GetArrayDouble vips_image_get_array_double retrieves a double array metadata value
func (r *Image) GetArrayDouble(name string) ([]float64, error) {
	return vipsImageGetArrayDouble(r.image, name)
}

// GetArrayInt vips_image_get_array_int retrieves an integer array metadata value
func (r *Image) GetArrayInt(name string) ([]int, error) {
	return vipsImageGetArrayInt(r.image, name)
}

// Exif extracts all EXIF metadata from the image and returns it as a map of field names to string values
func (r *Image) Exif() map[string]string {
	fields := vipsImageGetFields(r.image)
	exifData := map[string]string{}
	for _, field := range fields {
		if strings.HasPrefix(field, "exif") {
			if val, err := vipsImageGetString(r.image, field); err == nil {
				exifData[field] = val
			}
		}
	}
	return exifData
}

// SetOrientation sets the orientation in the EXIF header of the associated image.
func (r *Image) SetOrientation(orientation int) error {
	out, err := vipsgenCopy(r.image)
	if err != nil {
		return err
	}
	vipsSetMetaOrientation(out, orientation)
	r.setImage(out)
	return nil
}

// RemoveOrientation removes the EXIF orientation information of the image.
func (r *Image) RemoveOrientation() error {
	out, err := vipsgenCopy(r.image)
	if err != nil {
		return err
	}
	vipsRemoveMetaOrientation(out)
	r.setImage(out)
	return nil
}

// Pages returns the number of pages in the Image
// For animated images this corresponds to the number of frames
func (r *Image) Pages() int {
	{{range .ImageTypes}}{{if eq .TypeName "jp2k"}}
	// libvips uses the same attribute (n_pages) to represent the number of pyramid layers in JP2K
	// as we interpret the attribute as frames and JP2K does not support animation we override this with 1
	if r.format == ImageTypeJp2k {
		return 1
	}
	{{end}}{{end}}
	return vipsGetImageNPages(r.image)
}


// SetPages sets the number of pages in the Image
// For animated images this corresponds to the number of frames
func (r *Image) SetPages(pages int) error {
	out, err := vipsgenCopy(r.image)
	if err != nil {
		return err
	}
	vipsSetImageNPages(out, pages)
	r.setImage(out)
	return nil
}

// PageHeight return the height of a single page
func (r *Image) PageHeight() int {
	if r.pageHeight == 0 {
		r.pageHeight = vipsGetPageHeight(r.image)
	}
	return r.pageHeight
}

// SetPageHeight set the height of a page
// For animated images this is used when "unrolling" back to frames
func (r *Image) SetPageHeight(height int) error {
	vipsSetPageHeight(r.image, height)
	r.pageHeight = height
	return nil
}

// Background get the background of image.
func (r *Image) Background() ([]float64, error) {
	return vipsImageGetArrayDouble(r.image, "background")
}

// PageDelay gets the page delay array for animation
func (r *Image) PageDelay() ([]int, error) {
	return vipsImageGetArrayInt(r.image, "delay")
}

// GetICCProfile retrieves the ICC profile data (if any) from the image.
func (r *Image) GetICCProfile() ([]byte, bool) {
	return vipsGetICCProfile(r.image)
}

// RemoveICCProfile removes the ICC Profile information from the image.
// Typically, browsers and other software assume images without profile to be in the sRGB color space.
func (r *Image) RemoveICCProfile() error {
	out, err := vipsgenCopy(r.image)
	if err != nil {
		return err
	}
	vipsRemoveICCProfile(out)
	r.setImage(out)
	return nil
}

// RemoveExif removes all metadata from the image (except ICC profile)
func (r *Image) RemoveExif() error {
	out, err := vipsRemoveExif(r.image)
	if err != nil {
		return err
	}
	r.setImage(out)
	return nil
}

// Modulate the colors
func (r *Image) Modulate(brightness, saturation, hue float64) error {
	var err error
	var multiplications []float64
	var additions []float64
	colorspace := r.Interpretation()
	if colorspace == InterpretationRgb {
		colorspace = InterpretationSrgb
	}
	multiplications = []float64{brightness, saturation, 1}
	additions = []float64{0, 0, hue}
	if r.HasAlpha() {
		multiplications = append(multiplications, 1)
		additions = append(additions, 0)
	}
	err = r.Colourspace(InterpretationLch, nil)
	if err != nil {
		return err
	}
	err = r.Linear(multiplications, additions, nil)
	if err != nil {
		return err
	}
	err = r.Colourspace(colorspace, nil)
	if err != nil {
		return err
	}
	return nil
}

// ModulateHSV modulates the image HSV values based on the supplier parameters.
func (r *Image) ModulateHSV(brightness, saturation float64, hue int) error {
	var err error
	var multiplications []float64
	var additions []float64
	colorspace := r.Interpretation()
	if colorspace == InterpretationRgb {
		colorspace = InterpretationSrgb
	}
	if r.HasAlpha() {
		multiplications = []float64{1, saturation, brightness, 1}
		additions = []float64{float64(hue), 0, 0, 0}
	} else {
		multiplications = []float64{1, saturation, brightness}
		additions = []float64{float64(hue), 0, 0}
	}
	err = r.Colourspace(InterpretationHsv, nil)
	if err != nil {
		return err
	}
	err = r.Linear(multiplications, additions, nil)
	if err != nil {
		return err
	}
	err = r.Colourspace(colorspace, nil)
	if err != nil {
		return err
	}
	return nil
}

// EmbedMultiPageOptions are options for EmbedMultiPage method
type EmbedMultiPageOptions struct {
	// Extend determines how the image edges are extended
	Extend Extend
	// Background color components [0-255]
	Background []float64
}

// DefaultEmbedMultiPageOptions creates default options for EmbedMultiPage
func DefaultEmbedMultiPageOptions() *EmbedMultiPageOptions {
	return &EmbedMultiPageOptions{
		Extend:     ExtendBlack,
		Background: []float64{},
	}
}

// EmbedMultiPage embeds the image in a larger image with the specified dimensions
// When the image has multiple pages (e.g. animated GIF), this embeds each frame
func (r *Image) EmbedMultiPage(left, top, width, height int, options *EmbedMultiPageOptions) error {
	if options == nil {
		options = DefaultEmbedMultiPageOptions()
	}
	{{range .Operations}}{{if (eq .Name "embed")}}
	if r.Height() == r.PageHeight() {
		out, err := vipsgenEmbedWithOptions(r.image, left, top, width, height, options.Extend, options.Background)
		if err != nil {
			return err
		}
		r.setImage(out)
		return nil
	}
	{{end}}{{end}}
	if options.Extend == ExtendBackground {
		bg := []float64{0, 0, 0, 255}
		if len(options.Background) > 0 {
			for i := 0; i < len(options.Background) && i < 4; i++ {
				bg[i] = options.Background[i]
			}
		}
		out, err := vipsEmbedMultiPageBackground(
			r.image,
			left, top, width, height,
			int(bg[0]), int(bg[1]), int(bg[2]), int(bg[3]),
		)
		if err != nil {
			return err
		}
		r.setImage(out)
		return nil
	}
	out, err := vipsEmbedMultiPage(r.image, left, top, width, height, options.Extend)
	if err != nil {
		return err
	}
	r.setImage(out)
	return nil
}

// ExtractAreaMultiPage extracts a region from the image, working correctly with multi-page (animated) images
func (r *Image) ExtractAreaMultiPage(left, top, width, height int) error {
	{{range .Operations}}{{if (eq .Name "extract_area")}}
	if r.Height() == r.PageHeight() {
		out, err := vipsgenExtractArea(r.image, left, top, width, height)
		if err != nil {
			return err
		}
		r.setImage(out)
		return nil
	}
	{{end}}{{end}}
	out, err := vipsExtractAreaMultiPage(r.image, left, top, width, height)
	if err != nil {
		return err
	}
	r.setImage(out)
	return nil
}

// RotMultiPage rotates an image by a multiple of 90 degrees, working correctly with multi-page (animated) images
func (r *Image) RotMultiPage(angle Angle) error {
	{{range .Operations}}{{if (eq .Name "rot")}}
	if r.Height() == r.PageHeight() {
		out, err := vipsgenRot(r.image, angle)
		if err != nil {
			return err
		}
		r.setImage(out)
		return nil
	}
	{{end}}{{end}}
	out, err := vipsRotMultiPage(r.image, angle)
	if err != nil {
		return err
	}
	r.setImage(out)
	return nil
}

// LabelOptions are options for Label method
type LabelOptions struct {
	// Font name
	Font string
	// Text size
	Size int
	// Text alignment
	Align Align
	// Text color components [0-255]
	Color []float64
	// Text opacity (0-1)
	Opacity float64
}

// DefaultLabelOptions creates default options for Label
func DefaultLabelOptions() *LabelOptions {
	return &LabelOptions{
		Font:    "sans",
		Size:    12,
		Align:   AlignLow,
		Color:   []float64{0, 0, 0},
		Opacity: 1.0,
	}
}

// Label adds text to the image
func (r *Image) Label(text string, x, y int, options *LabelOptions) error {
	if options == nil {
		options = DefaultLabelOptions()
	}
	color := []float64{0, 0, 0}
	if options.Color != nil {
		for i := 0; i < len(options.Color) && i < 3; i++ {
			color[i] = options.Color[i]
		}
	}
	out, err := vipsLabel(r.image, text, options.Font,
		x, y, options.Size, options.Align,
		int(color[0]), int(color[1]), int(color[2]),
		options.Opacity,
	)
	if err != nil {
		return err
	}
	r.setImage(out)
	return nil
}
